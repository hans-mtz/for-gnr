<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="topic"/>
<meta name="DC.Title" content="pardiso iparm Parameter"/>
<meta name="DC.subject" content="Sparse Solvers, pardiso iparm parameter"/>
<meta name="keywords" content="Sparse Solvers, pardiso iparm parameter"/>
<meta name="DC.Relation" scheme="URI" content="GUID-7E829836-0FEF-46B2-8943-86A022193462.html"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>pardiso iparm Parameter</title>

</head>
<body class="no-rel-links" id="GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1">pardiso iparm Parameter</h1>
<div><p>This table describes all individual components of the 
      Intel&reg; oneAPI Math Kernel Library PARDISO<span class="parmname">iparm</span> parameter. Components which are not used must be initialized with 0. Default values are denoted with an asterisk (*). 
    </p>

<div class="tablenoborder"><table cellpadding="4" summary="" id="GUID-313A3EA7-CCEA-40D0-8226-EB9D4228FC3E" frame="hsides" border="1" rules="all"><thead align="left"><tr><th class="cellrowborder" valign="top" width="18.117977528089888%" id="d304125e36">Component 
            </th>
<th class="row-nocellborder" colspan="2" valign="top" id="d304125e38">Description 
            </th>
</tr>
</thead>
<tbody><tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><p><samp class="codeph" id="IPARM1"/><span><samp class="codeph"><span class="parmname">iparm</span>(1)</samp></span></p>
<p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Use default values. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><span><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(64)</samp></span> are filled with default values. 
            </td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 "><span class="eqsymbol">≠</span>0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 ">You must supply all values in components 
              <span><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(64)</samp></span>. 
            </td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><p><samp class="codeph" id="IPARM2"/><span><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></span></p>
<p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Fill-in reducing ordering for the input matrix. 
              </p>
<div class="Note"><h3 class="NoteTipHead">CAUTION</h3> <p>You can control the parallel execution of the solver by explicitly setting the 
                  <samp class="codeph">MKL_NUM_THREADS</samp> environment variable. If fewer OpenMP threads are available than specified, the execution may slow down instead of speeding up. If 
                  <samp class="codeph">MKL_NUM_THREADS</samp> is not defined, then the solver uses all available processors. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 ">The minimum degree algorithm 
              <a href="GUID-732F9EE1-BCEC-4D9B-9B93-AF5499B21140.html#LI99">[Li99]</a>. 
            </td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 ">The nested dissection algorithm from the METIS package 
              <a href="GUID-732F9EE1-BCEC-4D9B-9B93-AF5499B21140.html#KARYPIS98">[Karypis98]</a>. 
            </td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">3 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 ">The parallel (OpenMP) version of the nested dissection algorithm. It can decrease the time of computations on multi-core computers, especially when 
              Intel&reg; oneAPI Math Kernel Library PARDISO Phase 1 takes significant time. 
              <div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Setting 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></span><samp class="codeph"> = 3</samp> prevents the use of CNR mode (<span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span><samp class="codeph"> &gt; 0</samp>) because 
                  Intel&reg; oneAPI Math Kernel Library PARDISO uses dynamic parallelism. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM3"/><span><samp class="codeph"><span class="parmname">iparm</span>(3)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="5" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM4"/><span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Preconditioned CGS/CG. 
              </p>
<p>This parameter controls preconditioned CGS 
                <a href="GUID-732F9EE1-BCEC-4D9B-9B93-AF5499B21140.html#SONN89">[Sonn89]</a> for nonsymmetric or structurally symmetric matrices and Conjugate-Gradients for symmetric matrices. 
                <span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span> has the form 
                <span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span>= 
                <samp class="codeph">10*<var>L</var>+<var>K</var></samp>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 "><var>K</var>=0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The factorization is always computed as required by 
                <span class="parmname">phase</span>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 "><var>K</var>=1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CGS iteration replaces the computation of 
                <var>LU</var>. The preconditioner is 
                <var>LU</var> that was computed at a previous step (the first step or last step with a failure) in a sequence of solutions needed for identical sparsity patterns. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 "><var>K</var>=2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CGS iteration for symmetric positive definite matrices replaces the computation of 
                <var>LL</var><sup>T</sup>. The preconditioner is 
                <var>LL</var><sup>T</sup> that was computed at a previous step (the first step or last step with a failure) in a sequence of solutions needed for identical sparsity patterns. 
              </p>
</td>
</tr>
<tr><td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>The value 
                <var>L</var> controls the stopping criterion of the Krylov Subspace iteration: 
              </p>
<p><samp class="codeph">eps<sub class="subb"><var class="varnamett">CGS</var></sub> = 10<sup class="power"><var class="varname">-L</var></sup></samp> is used in the stopping criterion 
              </p>
<p><samp class="codeph">||<var>dx</var><sub class="subb"><var>i</var></sub>|| / ||<var>dx</var><sub class="subb"><var>0</var></sub>|| &lt; eps<sub class="subb"><var class="varnamett">CGS</var></sub></samp></p>
<p>where 
                <samp class="codeph">||<var>dx</var><sub class="subb"><var class="varname">i</var></sub>|| = ||inv(<var>L</var>*<var>U</var>)*<var>r</var><sub class="subb"><var>i</var></sub>||</samp> for 
                <samp class="codeph"><var>K</var> = 1</samp> or 
                <samp class="codeph">||<var>dx</var><sub class="subb"><var class="varname">i</var></sub>|| = ||inv(<var>L</var>*<var>L</var><sup>T</sup>)*<var>r</var><sub class="subb"><var>i</var></sub>||</samp> for 
                <samp class="codeph"><var>K</var> = 2</samp> and 
                <var>r</var><sub class="subb"><var>i</var></sub> is the residue at iteration 
                <var>i</var> of the preconditioned Krylov Subspace iteration. 
              </p>
<p>A maximum number of 150 iterations is fixed with the assumption that the iteration will converge before consuming half the factorization time. Intermediate convergence rates and residue excursions are checked and can terminate the iteration process. If 
                <samp class="codeph"><span class="parmname">phase</span> =23</samp>, then the factorization for a given 
                <var>A</var> is automatically recomputed in cases where the Krylov Subspace iteration failed, and the corresponding direct solution is returned. Otherwise the solution from the preconditioned Krylov Subspace iteration is returned. Using 
                <samp class="codeph"><span class="parmname">phase</span> =33</samp> results in an error message (<samp class="codeph"><span class="parmname">error</span>=-4</samp>) if the stopping criteria for the Krylov Subspace iteration can not be reached. More information on the failure can be obtained from 
                <a href="#IPARM20"><span><samp class="codeph"><span class="parmname">iparm</span>(20)</samp></span></a>. 
              </p>
<p>The default is 
                <span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span><samp class="codeph">=0</samp>, and other values are only recommended for an advanced user. 
                <span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span> must be greater than or equal to zero. 
              </p>
<p>Examples: 
              </p>
<dl id="GUID-92E39964-82AA-48DC-B69D-685DBD5FE64B"><dt><strong><span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span></strong></dt>
<dd><strong>Description 
                  </strong></dd>
<dt class="dlterm"><samp class="codeph">31 
                    </samp></dt>

<dd><var>LU</var>-preconditioned CGS iteration with a stopping criterion of 1.0E-3 for nonsymmetric matrices 
                  </dd>
<dt class="dlterm"><samp class="codeph">61 
                    </samp></dt>

<dd><var>LU</var>-preconditioned CGS iteration with a stopping criterion of 1.0E-6 for nonsymmetric matrices 
                  </dd>
<dt class="dlterm"><samp class="codeph">62 
                    </samp></dt>

<dd><var>LL</var><sup>T</sup>-preconditioned CGS iteration with a stopping criterion of 1.0E-6 for symmetric positive definite matrices 
                  </dd>
</dl>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM5"/><span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>User permutation. 
              </p>
<p>This parameter controls whether user supplied fill-in reducing permutation is used instead of the integrated multiple-minimum degree or nested dissection algorithms. Another use of this parameter is to control obtaining the fill-in reducing permutation vector calculated during the reordering stage of 
                Intel&reg; oneAPI Math Kernel Library PARDISO. 
              </p>
<p>This option is useful for testing reordering algorithms, adapting the code to special applications problems (for instance, to move zero diagonal elements to the end of 
                <samp class="codeph"><var>P</var>*<var>A</var>*<var>P</var><sup class="power"><var>T</var></sup></samp>), or for using the permutation vector more than once for matrices with identical sparsity structures. For definition of the permutation, see the description of the 
                <span class="parmname">perm</span> parameter. 
              </p>
<div class="Note"><h3 class="NoteTipHead">CAUTION</h3> <p>You can only set one of 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span>, 
                  <a href="#IPARM31"><span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span></a>, and 
                  <a href="#IPARM36"><span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span></a>, so be sure that the 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span> (partial solution) and the 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span> (Schur complement) parameters are 0 if you set 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span>. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>User permutation in the 
                <span class="parmname">perm</span> array is ignored. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses the user supplied fill-in reducing permutation from the<span class="parmname">perm</span> array. 
                <a href="#IPARM2"><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></a> is ignored. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Setting 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span> = 1 prevents use of a parallel algorithm for the solve step. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO returns the permutation vector computed at phase 1 in the<span class="parmname">perm</span> array. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM6"/><span><samp class="codeph"><span class="parmname">iparm</span>(6)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Write solution on 
                <span class="parmname">x</span>. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>The array 
                  <span class="parmname">x</span> is always used. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The array 
                <span class="parmname">x</span> contains the solution; right-hand side vector 
                <span class="parmname">b</span> is kept unchanged. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The solver stores the solution on the right-hand side 
                <span class="parmname">b</span>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM7"/><span><samp class="codeph"><span class="parmname">iparm</span>(7)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Number of iterative refinement steps performed. 
              </p>
<p>Reports the number of iterative refinement steps that were actually performed during the solve step. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM8"/><span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Iterative refinement step. 
              </p>
<p>On entry to the solve and iterative refinement step, 
                <span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span> must be set to the maximum number of iterative refinement steps that the solver performs. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The solver automatically performs two steps of iterative refinement when perturbed pivots are obtained during the numerical factorization. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Maximum number of iterative refinement steps that the solver performs. The solver performs not more than the absolute value of 
                <span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span> steps of iterative refinement. The solver might stop the process before the maximum number of steps if 
              </p>
<ul id="GUID-7BA17405-C4D1-468A-AF71-C3610D92DAAE"><li id="LI_B4B7D30B32B2484180B9033DB8080DC4"><p>a satisfactory level of accuracy of the solution in terms of backward error is achieved, 
                  </p>
</li>
<li id="LI_D9FB5F31125B4C0EAAA1AE782389AD16"><p>or if it determines that the required accuracy cannot be reached. In this case 
                    Intel&reg; oneAPI Math Kernel Library PARDISO returns -4 in the<span class="parmname">error</span> parameter. 
                  </p>
</li>
</ul>
<p>The number of executed iterations is reported in 
                <a href="#IPARM7"><span><samp class="codeph"><span class="parmname">iparm</span>(7)</samp></span></a>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&lt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Same as above, but the accumulation of the residuum uses extended precision real and complex data types. 
              </p>
<p>Perturbed pivots result in iterative refinement (independent of 
                <span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span><samp class="codeph">=0</samp>) and the number of executed iterations is reported in 
                <a href="#IPARM7"><span><samp class="codeph"><span class="parmname">iparm</span>(7)</samp></span></a>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM9"/><span><samp class="codeph"><span class="parmname">iparm</span>(9)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM10"/><span><samp class="codeph"><span class="parmname">iparm</span>(10)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Pivoting perturbation. 
              </p>
<p>This parameter instructs 
                Intel&reg; oneAPI Math Kernel Library PARDISO how to handle small pivots or zero pivots for nonsymmetric matrices (<samp class="codeph"><span class="parmname">mtype</span> =11</samp> or 
                <samp class="codeph"><span class="parmname">mtype</span> =13</samp>) and symmetric matrices (<samp class="codeph"><span class="parmname">mtype</span> =-2</samp>, 
                <samp class="codeph"><span class="parmname">mtype</span> =-4</samp>, or 
                <samp class="codeph"><span class="parmname">mtype</span> =6</samp>). For these matrices the solver uses a complete supernode pivoting approach. When the factorization algorithm reaches a point where it cannot factor the supernodes with this pivoting strategy, it uses a pivoting perturbation strategy similar to 
                <a href="GUID-732F9EE1-BCEC-4D9B-9B93-AF5499B21140.html#LI99">[Li99]</a>, 
                <a href="GUID-732F9EE1-BCEC-4D9B-9B93-AF5499B21140.html#SCHENK04">[Schenk04]</a>. 
              </p>
<p>Small pivots are perturbed with 
                <samp class="codeph">eps = 10<sup>-<span><samp class="codeph"><span class="parmname">iparm</span>(10)</samp></span></sup></samp>. 
              </p>
<p>The magnitude of the potential pivot is tested against a constant threshold of 
              </p>
<p><samp class="codeph">alpha = eps*||<var>A2</var>||<sub class="subb">inf</sub>,</samp></p>
<p>where 
                <samp class="codeph">eps = 10<sup class="power">(-<span><samp class="codeph"><span class="parmname">iparm</span>(10)</samp></span>)</sup></samp>, 
                <samp class="codeph"><var>A2</var> = 
                  <var>P</var>*<var>P</var><sub class="subb">MPS</sub>*<var>D</var><sub class="subb">r</sub>*<var>A</var>*<var>D</var><sub class="subb">c</sub>*<span class="parmname">P</span></samp>, and 
                <samp class="codeph">||<var>A2</var>||<sub class="subb">inf</sub></samp> is the infinity norm of the scaled and permuted matrix 
                <var>A</var>. Any tiny pivots encountered during elimination are set to the sign 
                <samp class="codeph">(<var>l</var><sub class="subb"><samp class="codeph">I</samp><samp class="codeph">I</samp></sub>)*eps*||<var>A2</var>||<sub class="subb">inf</sub></samp>, which trades off some numerical stability for the ability to keep pivots from getting too small. Small pivots are therefore perturbed with 
                <samp class="codeph">eps = 10<sup class="power"><samp class="codeph">(-<span><samp class="codeph"><span class="parmname">iparm</span>(10)</samp></span>)</samp></sup></samp>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">13* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The default value for nonsymmetric matrices(<span class="parmname">mtype</span> =11, 
                <span class="parmname">mtype</span>=13), 
                <samp class="codeph">eps = 10<sup>-13</sup></samp>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">8* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>The default value for symmetric indefinite matrices (<span class="parmname">mtype</span> =-2, 
                <span class="parmname">mtype</span>=-4, 
                <span class="parmname">mtype</span>=6), 
                <samp class="codeph">eps = 10<sup>-8</sup></samp>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM11"/><span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Scaling vectors. 
              </p>
<p>Intel&reg; oneAPI Math Kernel Library PARDISO uses a maximum weight matching algorithm to permute large elements on the diagonal and to scale so that the diagonal elements are equal to 1 and the absolute values of the off-diagonal entries are less than or equal to 1. This scaling method is applied only to nonsymmetric matrices (<span class="parmname">mtype</span> = 11 or 
                <span class="parmname">mtype</span> = 13). The scaling can also be used for symmetric indefinite matrices (<span class="parmname">mtype</span> = -2, 
                <span class="parmname">mtype</span> =-4, or 
                <span class="parmname">mtype</span> = 6) when the symmetric weighted matchings are applied (<a href="#IPARM13"><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span></a> = 1). 
              </p>
<p> Use 
                <span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span> = 1 (scaling) and 
                <a href="#IPARM13"><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span></a> = 1 (matching) for highly indefinite symmetric matrices, for example, from interior point optimizations or saddle point problems. Note that in the analysis phase (<span class="parmname">phase</span><span class="parmnamen">=11</span>) you must provide the numerical values of the matrix 
                <var>A</var> in array 
                <span class="parmname">a</span> in case of scaling and symmetric weighted matching. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Disable scaling. Default for symmetric indefinite matrices. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Enable scaling. Default for nonsymmetric matrices. 
              </p>
<p>Scale the matrix so that the diagonal elements are equal to 1 and the absolute values of the off-diagonal entries are less or equal to 1. This scaling method is applied to nonsymmetric matrices (<span class="parmname">mtype</span> = 11, 
                <span class="parmname">mtype</span> = 13). The scaling can also be used for symmetric indefinite matrices (<span class="parmname">mtype</span> = -2, 
                <span class="parmname">mtype</span> = -4, 
                <span class="parmname">mtype</span> = 6) when the symmetric weighted matchings are applied (<a href="#IPARM13"><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span></a> = 1). 
              </p>
<p>Note that in the analysis phase (<span class="parmname">phase</span>=11) you must provide the numerical values of the matrix 
                <var>A</var> in case of scaling. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM12"/><span><samp class="codeph"><span class="parmname">iparm</span>(12)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p> Solve with transposed or conjugate transposed matrix 
                <var>A</var>. 
              </p>
<p><div class="Note"><h3 class="NoteTipHead">Note</h3> <p> For real matrices, the terms 
                    <em>transposed</em> and 
                    <em>conjugate transposed</em> are equivalent. 
                  </p>
</div>
</p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Solve a linear system 
                <var>AX</var> = 
                <var>B</var>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Solve a conjugate transposed system 
                <var>A</var><sup><var>H</var></sup><var>X</var> = 
                <var>B</var> based on the factorization of the matrix 
                <var>A</var>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Solve a transposed system 
                <var>A</var><sup><var>T</var></sup><var>X</var> = 
                <var>B</var> based on the factorization of the matrix 
                <var>A</var>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM13"/><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Improved accuracy using (non-) symmetric weighted matching. 
              </p>
<p>Intel&reg; oneAPI Math Kernel Library PARDISO can use a maximum weighted matching algorithm to permute large elements close the diagonal. This strategy adds an additional level of reliability to the factorization methods and complements the alternative of using more complete pivoting techniques during the numerical factorization. 
              </p>
<p class="bold">   
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Disable matching. Default for symmetric indefinite matrices. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Enable matching. Default for nonsymmetric matrices. 
              </p>
<p>Maximum weighted matching algorithm to permute large elements close to the diagonal. 
              </p>
<p>It is recommended to use 
                <a href="#IPARM11"><span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span></a> = 1 (scaling) and 
                <span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span>= 1 (matching) for highly indefinite symmetric matrices, for example from interior point optimizations or saddle point problems. 
              </p>
<p>Note that in the analysis phase (<span class="parmname">phase</span>=11) you must provide the numerical values of the matrix 
                <var>A</var> in case of symmetric weighted matching. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM14"/><span><samp class="codeph"><span class="parmname">iparm</span>(14)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Number of perturbed pivots. 
              </p>
<p>After factorization, contains the number of perturbed pivots for the matrix types: 1, 3, 11, 13, -2, -4 and 6. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM15"/><span><samp class="codeph"><span class="parmname">iparm</span>(15)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Peak memory on symbolic factorization. 
              </p>
<p>The total peak memory in kilobytes that the solver needs during the analysis and symbolic factorization phase. 
              </p>
<p>This value is only computed in phase 1. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM16"/><span><samp class="codeph"><span class="parmname">iparm</span>(16)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Permanent memory on symbolic factorization. 
              </p>
<p>Permanent memory from the analysis and symbolic factorization phase in kilobytes that the solver needs in the factorization and solve phases. 
              </p>
<p>This value is only computed in phase 1. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM17"/><span><samp class="codeph"><span class="parmname">iparm</span>(17)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Size of factors/Peak memory on numerical factorization and solution. 
              </p>
<p>This parameter provides the size in kilobytes of the total memory consumed by in-core 
                Intel&reg; oneAPI Math Kernel Library PARDISO for internal floating point arrays. This parameter is computed in phase 1. See<a href="#IPARM63"><span><samp class="codeph"><span class="parmname">iparm</span>(63)</samp></span></a> for the OOC mode. 
              </p>
<p>The total peak memory consumed by 
                Intel&reg; oneAPI Math Kernel Library PARDISO is<samp class="codeph">max(<a href="#IPARM15"><span><samp class="codeph"><span class="parmname">iparm</span>(15)</samp></span></a>, 
                  <a href="#IPARM16"><span><samp class="codeph"><span class="parmname">iparm</span>(16)</samp></span></a>+<span><samp class="codeph"><span class="parmname">iparm</span>(17)</samp></span>)</samp></p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM18"/><span><samp class="codeph"><span class="parmname">iparm</span>(18)</samp></span><p>input/output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Report the number of non-zero elements in the factors. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&lt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Enable reporting if 
                <span><samp class="codeph"><span class="parmname">iparm</span>(18)</samp></span> &lt; 0 on entry. The default value is -1. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt;=0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Disable reporting. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM19"/><span><samp class="codeph"><span class="parmname">iparm</span>(19)</samp></span><p>input/output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Report number of floating point operations (in 10<sup>6</sup> floating point operations) that are necessary to factor the matrix 
                <var>A</var>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&lt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Enable report if 
                <span><samp class="codeph"><span class="parmname">iparm</span>(19)</samp></span> &lt; 0 on entry. This increases the reordering time. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt;=0 * 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Disable report. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM20"/><span><samp class="codeph"><span class="parmname">iparm</span>(20)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Report CG/CGS diagnostics. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CGS succeeded, reports the number of completed iterations. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&lt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CG/CGS failed (<span class="parmname">error</span>=-4 after the solution phase). 
              </p>
<p>If 
                <samp class="codeph"><span class="parmname">phase</span>= 23</samp>, then the factors 
                <var>L</var> and 
                <var>U</var> are recomputed for the matrix 
                <var>A</var> and the error flag 
                <samp class="codeph"><span class="parmname">error</span>=0</samp> in case of a successful factorization. If 
                <samp class="codeph"><span class="parmname">phase</span> = 33</samp>, then 
                <samp class="codeph"><span class="parmname">error</span> = -4</samp> signals failure. 
              </p>
<p><span><samp class="codeph"><span class="parmname">iparm</span>(20)</samp></span><samp class="codeph">= - it_cgs*10 - cgs_error</samp>. 
              </p>
<p>Possible values of 
                <samp class="codeph">cgs_error</samp>: 
              </p>
<p>1 - fluctuations of the residuum are too large 
              </p>
<p>2 - 
                <samp class="codeph">||dx<sub>max_it_cgs/2</sub>||</samp> is too large (slow convergence) 
              </p>
<p>3 - stopping criterion is not reached at 
                <samp class="codeph">max_it_cgs</samp></p>
<p>4 - perturbed pivots caused iterative refinement 
              </p>
<p>5 - factorization is too fast for this matrix. It is better to use the factorization method with 
                <a href="#IPARM4"><span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span></a> = 0 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="5" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM21"/><span><samp class="codeph"><span class="parmname">iparm</span>(21)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Pivoting for symmetric indefinite matrices. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p> Use 
                  <a href="#IPARM11"><span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span></a> = 1 (scaling) and 
                  <a href="#IPARM13"><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span></a> = 1 (matchings) for highly indefinite symmetric matrices, for example from interior point optimizations or saddle point problems. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Apply 1x1 diagonal pivoting during the factorization process. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Apply 1x1 and 2x2 Bunch-Kaufman pivoting during the factorization process. Bunch-Kaufman pivoting is available for matrices of 
                <samp class="codeph"><span class="parmname">mtype</span>=-2</samp>, 
                <samp class="codeph"><span class="parmname">mtype</span>=-4</samp>, or 
                <samp class="codeph"><span class="parmname">mtype</span>=6</samp>. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Apply 1x1 diagonal pivoting during the factorization process. Using this value is the same as using 
                <span><samp class="codeph"><span class="parmname">iparm</span>(21)</samp></span> = 0 except that the solve step does not automatically make iterative refinements when perturbed pivots are obtained during numerical factorization. The number of iterations is limited to the number of iterative refinements specified by 
                <span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span> (0 by default). 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">3 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Apply 1x1 and 2x2 Bunch-Kaufman pivoting during the factorization process. Bunch-Kaufman pivoting is available for matrices of 
                <samp class="codeph"><span class="parmname">mtype</span>=-2</samp>, 
                <samp class="codeph"><span class="parmname">mtype</span>=-4</samp>, or 
                <samp class="codeph"><span class="parmname">mtype</span>=6</samp>. Using this value is the same as using 
                <span><samp class="codeph"><span class="parmname">iparm</span>(21)</samp></span> = 1 except that the solve step does not automatically make iterative refinements when perturbed pivots are obtained during numerical factorization. The number of iterations is limited to the number of iterative refinements specified by 
                <span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span> (0 by default). 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM22"/><span><samp class="codeph"><span class="parmname">iparm</span>(22)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Inertia: number of positive eigenvalues. 
              </p>
<p>Intel&reg; oneAPI Math Kernel Library PARDISO reports the number of positive eigenvalues for symmetric indefinite matrices. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM23"/><span><samp class="codeph"><span class="parmname">iparm</span>(23)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Inertia: number of negative eigenvalues. 
              </p>
<p>Intel&reg; oneAPI Math Kernel Library PARDISO reports the number of negative eigenvalues for symmetric indefinite matrices. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM24"/><span><samp class="codeph"><span class="parmname">iparm</span>(24)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p> Parallel factorization control. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses the classic algorithm for factorization. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses a two-level factorization algorithm. This algorithm generally improves scalability in case of parallel factorization on many OpenMP threads (more than eight). 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> Disable 
                <span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span> (scaling) and 
                <span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span>= 1 (matching) when using the two-level factorization algorithm. Otherwise 
                Intel&reg; oneAPI Math Kernel Library PARDISO uses the classic factorization algorithm. 
              </div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">10 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses an improved two-level factorization algorithm for nonsymmetric matrices. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM25"/><span><samp class="codeph"><span class="parmname">iparm</span>(25)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p> Parallel forward/backward solve control. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses the following strategy for parallelizing the solving step: 
              </p>
<p>In the case of the one right-hand side, the parallelization will be performed by partitioning the matrix. 
              </p>
<p>Otherwise, the parallelization will be over the right-hand sides. 
              </p>
<p><p>This feature is available only for in-core 
                  Intel&reg; oneAPI Math Kernel Library PARDISO (see<a href="#IPARM60"><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span></a>). 
                </p>
</p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO uses the sequential forward and backward solve. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Independent from the number of the right-hand sides, 
                Intel&reg; oneAPI Math Kernel Library PARDISO uses the parallel algorithm based on the matrix partitioning. 
              </p>
<p><p>This feature is available only for in-core 
                  Intel&reg; oneAPI Math Kernel Library PARDISO (see<a href="#IPARM60"><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span></a>). 
                </p>
</p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM26"/><span><samp class="codeph"><span class="parmname">iparm</span>(26)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM27"/><span><samp class="codeph"><span class="parmname">iparm</span>(27)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Matrix checker. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO does not check the sparse matrix representation for errors. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO checks integer arrays<span class="parmname">ia</span> and 
                <span class="parmname">ja</span>. In particular, 
                Intel&reg; oneAPI Math Kernel Library PARDISO checks whether column indices are sorted in increasing order within each row. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM28"/><span><samp class="codeph"><span class="parmname">iparm</span>(28)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Single or double precision 
                Intel&reg; oneAPI Math Kernel Library PARDISO. 
              </p>
<p>See 
                <a href="#IPARM8"><span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span></a> for information on controlling the precision of the refinement steps. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Important</h3> <p>The 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(28)</samp></span>value is stored in the 
                  Intel&reg; oneAPI Math Kernel Library PARDISO handle between 
                  Intel&reg; oneAPI Math Kernel Library PARDISO calls, so the precision mode can be changed only during phase 1. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Input arrays (<span class="parmname">a</span>, 
                <span class="parmname">x</span> and 
                <span class="parmname">b</span>) and all internal arrays must be presented in double precision. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Input arrays (<span class="parmname">a</span>, 
                <span class="parmname">x</span> and 
                <span class="parmname">b</span>) must be presented in single precision. 
              </p>
<p>In this case all internal computations are performed in single precision. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM29"/><span><samp class="codeph"><span class="parmname">iparm</span>(29)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM30"/><span><samp class="codeph"><span class="parmname">iparm</span>(30)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Number of zero or negative pivots. 
              </p>
<p>If 
                Intel&reg; oneAPI Math Kernel Library PARDISO detects zero or negative pivot for<span class="parmname">mtype</span>=2 or 
                <span class="parmname">mtype</span>=4 matrix types, the factorization is stopped. 
                Intel&reg; oneAPI Math Kernel Library PARDISO returns immediately with an<span class="parmname">error</span> = -4, and 
                <span><samp class="codeph"><span class="parmname">iparm</span>(30)</samp></span> reports the number of the equation where the zero or negative pivot is detected. 
              </p>
<p>Note: The returned value can be different for the parallel and sequential version in case of several zero/negative pivots. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="5" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM31"/><span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p> Partial solve and computing selected components of the solution vectors. 
              </p>
<p>This parameter controls the solve step of 
                Intel&reg; oneAPI Math Kernel Library PARDISO. It can be used if only a few components of the solution vectors are needed or if you want to reduce the computation cost at the solve step by utilizing the sparsity of the right-hand sides. To use this option the input permutation vector define<span class="parmname">perm</span> so that when 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1 it means that either the 
                <var>i</var>-th component in the right-hand sides is nonzero, or the 
                <var>i</var>-th component in the solution vectors is computed, or both, depending on the value of 
                <span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span>. 
              </p>
<p> The permutation vector 
                <span class="parmname">perm</span>must be present in all phases of 
                Intel&reg; oneAPI Math Kernel Library PARDISO software. At the reordering step, the software overwrites the input vector<span class="parmname">perm</span> by a permutation vector used by the software at the factorization and solver step. If 
                <span class="parmname">m</span> is the number of components such that 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1, then the last 
                <span class="parmname">m</span> components of the output vector 
                <span class="parmname">perm</span> are a set of the indices 
                <var>i</var> satisfying the condition 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1 on input. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Turning on this option often increases the time used by 
                  Intel&reg; oneAPI Math Kernel Library PARDISO for factorization and reordering steps, but it can reduce the time required for the solver step. 
                </p>
</div>
<div class="Note"><h3 class="NoteTipHead">Important</h3> <p>You can use this feature for both in-core and out-of-core 
                  Intel&reg; oneAPI Math Kernel Library PARDISO as long as iparm[23]=1. Otherwise, you cannot use partial solve for out-of-core mode and you will need to set<a href="#IPARM60"><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span></a>=0 for in-core mode. Set the parameters 
                  <a href="#IPARM8"><span><samp class="codeph"><span class="parmname">iparm</span>(8)</samp></span></a> (iterative refinement steps), 
                  <a href="#IPARM4"><span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp></span></a> (preconditioned CGS), 
                  <a href="#IPARM5"><span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span></a> (user permutation), and 
                  <a href="#IPARM36"><span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span></a> (Schur complement) to 0 as well. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Disables this option. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p> it is assumed that the right-hand sides have only a few non-zero components<a href="#NZ"><sup>*</sup></a> and the input permutation vector 
                <span class="parmname">perm</span> is defined so that 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1 means that the (<var>i</var>)-th component in the right-hand sides is nonzero. In this case 
                Intel&reg; oneAPI Math Kernel Library PARDISO only uses the non-zero components of the right-hand side vectors and computes only corresponding components in the solution vectors. That means the<var>i</var>-th component in the solution vectors is only computed if 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p> It is assumed that the right-hand sides have only a few non-zero components<a href="#NZ"><sup>*</sup></a> and the input permutation vector 
                <span class="parmname">perm</span> is defined so that 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1 means that the 
                <var>i</var>-th component in the right-hand sides is nonzero. 
              </p>
<p> Unlike for 
                <span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span>=1, all components of the solution vector are computed for this setting and all components of the right-hand sides are used. Because all components are used, for 
                <span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span>=2 you must set the 
                <var>i</var>-th component of the right-hand sides to zero explicitly if 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> is not equal to 1. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">3 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Selected components of the solution vectors are computed. The 
                <span class="parmname">perm</span> array is not related to the right-hand sides and it only indicates which components of the solution vectors should be computed. In this case 
                <span class="parmname">perm</span><samp class="codeph">(<var>i</var>)</samp> = 1 means that the 
                <var>i</var>-th component in the solution vectors is computed. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM32"/><span><samp class="codeph"><span class="parmname">iparm</span>(32)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(33)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM34"/><span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Optimal number of OpenMP threads for conditional numerical reproducibility (CNR) mode. 
              </p>
<p>Intel&reg; oneAPI Math Kernel Library PARDISO reads the value of<span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span> during the analysis phase (phase 1), so you cannot change it later. 
              </p>
<p>Because 
                Intel&reg; oneAPI Math Kernel Library PARDISO uses C random number generator facilities during the analysis phase (phase 1) you must take these precautions to get numerically reproducible results: 
              </p>
<ul id="GUID-BD5B3939-F2B6-4F4D-BD10-E3DDD8F1B4BC"><li id="LI_C446216F01F94D0B84E28732EC31B141"><p>Do not alter the states of the random number generators. 
                  </p>
</li>
<li id="LI_AF18557EFB0A4BD19AAD0AB4D8375885"><p>Do not run multiple instances of 
                    Intel&reg; oneAPI Math Kernel Library PARDISO in parallel in the analysis phase (phase 1). 
                  </p>
</li>
</ul>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>CNR is only available for the in-core version of 
                  Intel&reg; oneAPI Math Kernel Library PARDISO and the non-parallel version of the nested dissection algorithm. You must also: 
                </p>
<ul id="GUID-924E4B05-0A31-4F67-8225-57C5EDDDE3BE"><li id="LI_086DCD97620F4C57A49A6605E6D02342"><p>set 
                      <a href="#IPARM60"><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span></a> to 0 in order to use the in-core version, 
                    </p>
</li>
<li id="LI_B30C9DC7A43C4332BD9CE1AEB3B02AFC"><p>not set 
                      <span><samp class="codeph"><span class="parmname">iparm</span>(2)</samp></span> to 3 in order to not use the parallel version of the nested dissection algorithm. 
                    </p>
</li>
</ul>
<p>Otherwise 
                  Intel&reg; oneAPI Math Kernel Library PARDISO does not produce numerically repeatable results even if CNR is enabled for 
                  Intel&reg; oneAPI Math Kernel Library using the functionality described in<a href="GUID-48D42214-B574-4DE9-BC8A-0F2A80C12D0B.html">Support Functions for CNR</a>. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CNR mode for 
                Intel&reg; oneAPI Math Kernel Library PARDISO is enabled only if it is enabled for 
                Intel&reg; oneAPI Math Kernel Library using the functionality described in<a href="GUID-48D42214-B574-4DE9-BC8A-0F2A80C12D0B.html">Support Functions for CNR</a>and the in-core version is used. 
                Intel&reg; oneAPI Math Kernel Library PARDISO determines the optimal number of OpenMP threads automatically, and produces numerically reproducible results regardless of the number of threads. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt;0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>CNR mode is enabled for 
                Intel&reg; oneAPI Math Kernel Library PARDISO if in-core version is used and the optimal number of OpenMP threads for 
                Intel&reg; oneAPI Math Kernel Library PARDISO to rely on is defined by the value of<span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span>. You can use 
                <span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span>to enable CNR mode independent from other 
                Intel&reg; oneAPI Math Kernel Library domains. To get the best performance, set<span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span>to the actual number of hardware threads dedicated for 
                Intel&reg; oneAPI Math Kernel Library PARDISO. Setting<span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span> to fewer OpenMP threads than the maximum number of them in use reduces the scalability of the problem being solved. Setting 
                <span><samp class="codeph"><span class="parmname">iparm</span>(34)</samp></span>to more threads than are available can reduce the performance of 
                Intel&reg; oneAPI Math Kernel Library PARDISO. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM35"/><span><samp class="codeph"><span class="parmname">iparm</span>(35)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>One- or zero-based indexing of columns and rows. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p> Schur complement may be inaccurate or incorrect if pivots are detected. 
                </p>
<p> Please, check the output of 
                  <a href="#IPARM29"><span><samp class="codeph"><span class="parmname">iparm</span>(29)</samp></span></a> . 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>One-based indexing: columns and rows indexing in arrays 
                <span class="parmname">ia</span>, 
                <span class="parmname">ja</span>, and 
                <span class="parmname">perm</span> starts from 1 (Fortran-style indexing). 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Zero-based indexing: columns and rows indexing in arrays 
                <span class="parmname">ia</span>, 
                <span class="parmname">ja</span>, and 
                <span class="parmname">perm</span> starts from 0 (C-style indexing). 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="6" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM36"/><span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span><p>input/output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Schur complement matrix computation control. To calculate this matrix, you must set the input permutation vector 
                <span class="parmname">perm</span> to a set of indexes such that when 
                <samp class="codeph"><span class="parmname">perm</span>(<var>i</var>) = 1</samp>, the 
                <var>i</var>-th element of the initial matrix is an element of the Schur matrix. 
              </p>
<div class="Note"><h3 class="NoteTipHead">CAUTION</h3> <p>You can only set one of 
                  <a href="#IPARM5"><span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span></a>, 
                  <a href="#IPARM31"><span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span></a>, and 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span>, so be sure that the 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(5)</samp></span> (user permutation) and the 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span> (partial solution) parameters are 0 if you set 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span>. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Do not compute Schur complement. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Compute Schur complement matrix as part of 
                Intel&reg; oneAPI Math Kernel Library PARDISO factorization step and return it in the solution vector. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>This option only computes the Schur complement matrix, and does not calculate factorization arrays. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Compute Schur complement matrix as part of 
                Intel&reg; oneAPI Math Kernel Library PARDISO factorization step and return it in the solution vector. Since this option calculates factorization arrays you can use it to launch partial or full solution of the entire problem after the factorization step. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">-1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Same as 
                <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span> equals 1, but the Schur complement matrix is provided in 3-array CSR sparse format. Use in combination with 
                <a href="GUID-E8CE439A-3F76-4EB8-934E-7C37C83BAF44.html"><span class="option">pardiso_export</span></a>. After reordering stage of MKL PARDISO, 
                <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span> contains number of nonzero elements for Schur complement matrix. Set it once again before calling the factorization phase. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p> This option is available only when 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(24)</samp></span>is not equal to 0. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">-2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Same as 
                <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span> equals 2, but the Schur complement matrix is provided in 3-array CSR sparse format. Use in combination with 
                <a href="GUID-E8CE439A-3F76-4EB8-934E-7C37C83BAF44.html"><span class="option">pardiso_export</span></a>. After reordering stage of MKL PARDISO, 
                <span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span> contains number of nonzero elements for Schur complement matrix. Set it once again before calling the factorization phase. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p> This option is available only when 
                  <span><samp class="codeph"><span class="parmname">iparm</span>(24)</samp></span>is not equal to 0. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM37"/><span><samp class="codeph"><span class="parmname">iparm</span>(37)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Format for matrix storage. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Use CSR format (see 
                <a href="GUID-3FD9A93D-CA65-4321-BED6-7593C6EEDB60.html#CSR3">Three Array Variation of CSR Format</a>) for matrix storage. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&gt; 0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Use BSR format (see 
                <a href="GUID-4BA1807B-DC76-48BD-B18F-F96EDC6617F1.html#GUID-9BD4DADE-6059-4042-BC2A-F41048A47953">Three Array Variation of BSR Format</a>) for matrix storage with blocks of size 
                <span><samp class="codeph"><span class="parmname">iparm</span>(37)</samp></span>. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Intel&reg; oneAPI Math Kernel Library does not support BSR format in these cases: 
                </p>
<ul id="GUID-D06698CB-B9CD-4A31-BD51-9C94A68D1E91"><li id="LI_8355DB8A77A3466B98508AEC2CA63D62"><p><span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span><samp class="codeph"> &gt; 0</samp>: Scaling vectors 
                    </p>
</li>
<li id="LI_D398F515E67C4DE08A360153DC9BA5A2"><p><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span><samp class="codeph"> &gt; 0</samp>: Weighted matching 
                    </p>
</li>
<li id="LI_7D8011845CDB4BE6B691172320E42F6B"><p><span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span><samp class="codeph"> &gt; 0</samp>: Partial solution 
                    </p>
</li>
<li id="LI_A8CB39FF34D24A8A83BCD6CC722741F0"><p><span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span><samp class="codeph"> &gt; 0</samp>: Schur complement 
                    </p>
</li>
<li id="LI_C13EA10F7255456F902290BD4896490C"><p><span><samp class="codeph"><span class="parmname">iparm</span>(56)</samp></span><samp class="codeph"> &gt; 0</samp>: Pivoting control 
                    </p>
</li>
<li id="LI_B099A5039FED49BEA349AFFE3CA322BC"><p><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span><samp class="codeph"> &gt; 0</samp>: OOC 
                      Intel&reg; oneAPI Math Kernel Library PARDISO 
                    </p>
</li>
</ul>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">&lt; 0 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Convert supplied matrix to variable BSR (VBSR) format (see 
                <a href="GUID-7E829836-0FEF-46B2-8943-86A022193462.html#GUID-D309FCF9-4568-44D1-A199-E54E04D624C8">Sparse Data Storage</a>) for matrix storage. 
                Intel&reg; oneAPI Math Kernel Library PARDISO analyzes the matrix provided in CSR3 format and converts it to an internal VBSR format. Set<samp class="codeph"><span class="parmname">iparm</span>(37)</samp><samp class="codeph"> = -<var>t</var></samp>, 0 &lt; 
                <var>t</var><span class="eqsymbol">≤</span> 100. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Intel&reg; oneAPI Math Kernel Library supports only the VBSR format for real and symmetric positive definite or indefinite matrices (<span class="parmname">mtype</span> = 2 or 
                  <span class="parmname">mtype</span>= -2). 
                  Intel&reg; oneAPI Math Kernel Library does not support VBSR format in these cases: 
                </p>
<ul id="GUID-E8C040EF-5F1B-4AF7-B1AA-3C609827F3ED"><li id="LI_C9199FE512D6468382F98FF21ABEE2DC"><p><span><samp class="codeph"><span class="parmname">iparm</span>(11)</samp></span><samp class="codeph"> &gt; 0</samp>: Scaling vectors 
                    </p>
</li>
<li id="LI_AC55CA2DD9C840C0AFDA8AB434A7F9CC"><p><span><samp class="codeph"><span class="parmname">iparm</span>(13)</samp></span><samp class="codeph"> &gt; 0</samp>: Weighted matching 
                    </p>
</li>
<li id="LI_7276AE03FDD64FF2B4CF1ABD3C49821A"><p><span><samp class="codeph"><span class="parmname">iparm</span>(56)</samp></span><samp class="codeph"> &gt; 0</samp>: Pivoting control 
                    </p>
</li>
</ul>
</div>
<div class="Note"><h3 class="NoteTipHead">Note</h3> Intel&reg; oneAPI Math Kernel Library supports these features for all matrix types as long as<samp class="codeph"><span class="parmname">iparm</span>(24)</samp>=1: 
                <ul id="GUID-B1A72F34-96B1-4AF5-A3F3-316B8F12325F"><li id="LI_5E27DF29B5B443A783296341AE2D8079"><p><span><samp class="codeph"><span class="parmname">iparm</span>(31)</samp></span><samp class="codeph"> &gt; 0</samp>: Partial solution 
                    </p>
</li>
<li id="LI_1F59B31581BB442C89B2925154A594A8"><p><span><samp class="codeph"><span class="parmname">iparm</span>(36)</samp></span><samp class="codeph"> &gt; 0</samp>: Schur complement 
                    </p>
</li>
<li id="LI_D9DE87CD1218453281F96CBB2F088A9B"><p><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span><samp class="codeph"> &gt; 0</samp>: OOC 
                      Intel&reg; oneAPI Math Kernel Library PARDISO 
                    </p>
</li>
</ul>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><span><samp class="codeph"><span class="parmname">iparm</span>(38)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM39"/><span><samp class="codeph"><span class="parmname">iparm</span>(39)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Enable low rank update (see 
                <a href="GUID-7E829836-0FEF-46B2-8943-86A022193462.html#LOW_RANK">Low Rank Update</a>) to accelerate factorization for multiple matrices with identical structure and similar values. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Do not use low rank update functionality. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Use low rank update functionality. You must also set 
                <samp class="codeph"><samp class="codeph"><span class="parmname">iparm</span>(24)</samp> = 10</samp> and provide a list of changed values in the 
                <span class="parmname">perm</span> array. 
              </p>
<p>This option requires the default settings of 
                <span><samp class="codeph"><span class="parmname">iparm</span>(4)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(5)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(6)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(12)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(28)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(31)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(36)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(37)</samp>, 
                  <samp class="codeph"><span class="parmname">iparm</span>(56)</samp>, and 
                  <samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span> as well. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><span><samp class="codeph"><span class="parmname">iparm</span>(40)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(42)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM42"/><span><samp class="codeph"><span class="parmname">iparm</span>(43)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p> Control parameter for the computation of the diagonal of inverse matrix. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Do not compute the diagonal of inverse matrix. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO computes the diagonal of the inverse matrix during the factorization phase. This feature is only available with two-level factorization algorithm (<samp class="codeph"><span class="parmname">iparm</span>(24)</samp> = 1) and real symmetric matrices (<span class="parmname">mtype</span> = 2 or 
                <span class="parmname">mtype</span> = -2). The diagonal is returned in the solution vector. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><span><samp class="codeph"><span class="parmname">iparm</span>(44)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(55)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="3" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM56"/><span><samp class="codeph"><span class="parmname">iparm</span>(56)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Diagonal and pivoting control. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p> Internal function used to work with pivot and calculation of diagonal arrays turned off. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>You can use the 
                <a href="GUID-25061027-AC23-4BD5-80F6-48168458416F.html">mkl_pardiso_pivot</a> callback routine to control pivot elements which appear during numerical factorization. Additionally, you can obtain the elements of initial matrix and factorized matrices after the 
                <span class="keyword">pardiso</span> factorization step diagonal using the 
                <a href="GUID-2C3EA4B8-1203-4AB2-A8CD-39B99B89E762.html">pardiso_getdiag</a>routine. This parameter can be turned on only in the in-core version of 
                Intel&reg; oneAPI Math Kernel Library PARDISO. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph"/><span><samp class="codeph"><span class="parmname">iparm</span>(57)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(59)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" rowspan="4" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM60"/><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span><p>input 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Intel&reg; oneAPI Math Kernel Library PARDISO mode. 
              </p>
<p><span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span>switches between in-core (IC) and out-of-core (OOC) 
                Intel&reg; oneAPI Math Kernel Library PARDISO. OOC can solve very large problems by holding the matrix factors in files on the disk, which requires a reduced amount of main memory compared to IC. 
              </p>
<p>Unless you are operating in sequential mode, you can switch between IC and OOC modes after the reordering phase. However, you can get better 
                Intel&reg; oneAPI Math Kernel Library PARDISO performance by setting<span><samp class="codeph"><span class="parmname">iparm</span>(60)</samp></span> before the reordering phase. 
              </p>
<p>The amount of memory used in OOC mode depends on the number of OpenMP threads. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Warning</h3> <p> Do not increase the number of OpenMP threads used for cluster_sparse_solver between the first call and the factorization or solution phase. Because the minimum amount of memory required for out-of-core execution depends on the number of OpenMP threads, increasing it after the initial call can cause incorrect results.</p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">0* 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>IC mode. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">1 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>IC mode is used if the total amount of RAM (in megabytes) needed for storing the matrix factors is less than sum of two values of the environment variables: 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span> (default value 2000 MB) and 
                <span class="keyword">MKL_PARDISO_OOC_MAX_SWAP_SIZE</span> (default value 0 MB); otherwise OOC mode is used. In this case amount of RAM used by OOC mode cannot exceed the value of 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span>. 
              </p>
<p>If the total peak memory needed for storing the local arrays is more than 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span>, increase 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span> if possible. 
              </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Conditional numerical reproducibility (CNR) is not supported for this mode. 
                </p>
</div>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="7.02247191011236%" headers="d304125e38 ">2 
            </td>
<td class="row-nocellborder" valign="top" width="74.85955056179775%" headers="d304125e38 "><p>OOC mode. 
              </p>
<p>The OOC mode can solve very large problems by holding the matrix factors in files on the disk. Hence the amount of RAM required by OOC mode is significantly reduced compared to IC mode. 
              </p>
<p>If the total peak memory needed for storing the local arrays is more than 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span>, increase 
                <span class="keyword">MKL_PARDISO_OOC_MAX_CORE_SIZE</span> if possible. 
              </p>
<p id="OOC_NRHS">To obtain better 
                Intel&reg; oneAPI Math Kernel Library PARDISO performance, during the numerical factorization phase you can provide the maximum number of right-hand sides, which can be used further during the solving phase. 
              </p>
<p>Refer to 
                <a href="https://software.intel.com/en-us/articles/how-to-use-ooc-pardiso" target="_blank">How to use Intel&reg; MKL OOC PARDISO</a> and 
                <a href="GUID-7E829836-0FEF-46B2-8943-86A022193462.html">Storage of Matrices</a> for more details about OOC. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM61"/><span><samp class="codeph"><span class="parmname">iparm</span>(61)</samp></span> - 
              <span><samp class="codeph"><span class="parmname">iparm</span>(62)</samp></span></td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph" id="IPARM63"/><span><samp class="codeph"><span class="parmname">iparm</span>(63)</samp></span><p>output 
              </p>
</td>
<td class="row-nocellborder" colspan="2" valign="top" headers="d304125e38 "><p>Size of the minimum OOC memory for numerical factorization and solution. 
              </p>
<p>This parameter provides the size in kilobytes of the minimum memory required by OOC 
                Intel&reg; oneAPI Math Kernel Library PARDISO for internal floating point arrays. This parameter is computed in phase 1. 
              </p>
<p>Total peak memory consumption of OOC 
                Intel&reg; oneAPI Math Kernel Library PARDISO can be estimated as<span class="keyword">max</span>(<a href="#IPARM15"><span><samp class="codeph"><span class="parmname">iparm</span>(15)</samp></span></a>, 
                <a href="#IPARM16"><span><samp class="codeph"><span class="parmname">iparm</span>(16)</samp></span></a> + 
                <span><samp class="codeph"><span class="parmname">iparm</span>(63)</samp></span>). 
              </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="18.117977528089888%" headers="d304125e36 "><samp class="codeph"/><span><samp class="codeph"><span class="parmname">iparm</span>(64)</samp></span></td>
<td class="row-nocellborder" valign="top" headers="d304125e38 "><p>Reserved. Set to zero. 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p id="NZ">Generally in sparse matrices, components which are equal to zero can be considered non-zero if necessary. For example, in order to make a matrix structurally symmetric, elements which are zero can be considered non-zero. See 
        <a href="GUID-9FCEB1C4-670D-4738-81D2-F378013412B0.html#GUID-9FCEB1C4-670D-4738-81D2-F378013412B0">Sparse Matrix Storage Formats</a> for an example. 
      </p>
</div>
<p>
<div class="tablenoborder"><table cellpadding="4" summary="" id="d433e46" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" align="left" valign="top" width="100%" id="d304125e3242"><p id="d433e52">Optimization Notice 
              </p>
</th>
</tr>
</thead>
<tbody><tr><td class="bgcolor(#f5f5f5)" bgcolor="#f5f5f5" valign="top" width="100%" headers="d304125e3242 "><p>Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
              </p>
<p> Notice revision #20110804 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
 This notice covers the following instruction sets: SSE2, SSE4.2, AVX2, AVX-512. 
    </p>
</div>
<div/>
</body>
</html>
