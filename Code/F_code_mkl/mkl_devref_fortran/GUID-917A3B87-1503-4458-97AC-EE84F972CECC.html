<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="?heevr"/>
<meta name="abstract" content="Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix using the Relatively Robust Representations."/>
<meta name="description" content="Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix using the Relatively Robust Representations."/>
<meta name="DC.subject" content="?heevr, LAPACK routines, driver routines, symmetric eigenproblems"/>
<meta name="keywords" content="?heevr, LAPACK routines, driver routines, symmetric eigenproblems"/>
<meta name="DC.Relation" scheme="URI" content="GUID-258D5408-0894-424A-83B2-33DE708A319C.html"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-917A3B87-1503-4458-97AC-EE84F972CECC"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>?heevr</title>

</head>
<body id="GUID-917A3B87-1503-4458-97AC-EE84F972CECC">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">?heevr</span></h1>
<!--Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix using the Relatively Robust Representations.--><div><p class="shortdesc">Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix using the Relatively Robust Representations.</p>
<div class="section" id="GUID-F3F6CE57-6527-4CDE-8ACC-8F8414A0031B"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call cheevr</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">ldz</span><span class="sep">, </span><span class="var">isuppz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">lrwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call zheevr</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">ldz</span><span class="sep">, </span><span class="var">isuppz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">lrwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p></dl><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call heevr</span><span class="delim">(</span><span class="var">a</span><span class="sep">, </span><span class="var">w</span><span class="delim"> [</span><span class="sep">,</span><span class="var">uplo</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">z</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">vl</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">vu</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">il</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">iu</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">m</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">isuppz</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">abstol</span><span class="delim">] </span><span class="delim">[</span><span class="sep">,</span><span class="var">info</span><span class="delim">]</span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-BB82133B-C9C3-4CDB-86C1-99AC5013EB45"><h2 class="sectiontitle">Include Files</h2><ul id="d163e55"><li><span class="filepath">mkl.fi</span>, <span class="filepath">lapack.f90</span></li>
</ul>
</div>
<div class="section" id="GUID-63EEB385-2E34-4839-8220-7D537A4B2E59"><h2 class="sectiontitle">Description</h2><p><span/></p>
<p>The routine computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix <var>A</var>. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues. </p>
<p>The routine first reduces the matrix <var>A</var> to tridiagonal form <var>T</var> with a call to <a href="GUID-1371B572-C7DA-4F0F-AAD5-246AED285650.html#GUID-1371B572-C7DA-4F0F-AAD5-246AED285650">hetrd</a>.  Then, whenever possible, <span class="option">?heevr</span> calls <a href="GUID-B39E896C-377D-4755-ACDC-821F1EAC6739.html#GUID-B39E896C-377D-4755-ACDC-821F1EAC6739">stegr</a> to compute the eigenspectrum using Relatively Robust Representations. <span class="option">?stegr</span> computes eigenvalues by the <var>dqds</var> algorithm, while orthogonal eigenvectors are computed from various "good" <var>L*D*L</var><sup class="power"><var>T</var></sup> representations (also known as Relatively Robust Representations). Gram-Schmidt orthogonalization is avoided as far as possible. More specifically, the various steps of the algorithm are as follows. For each unreduced block (submatrix) of <var>T</var>:</p>
<ol class="abc" id="GUID-AA3D20EC-7A0B-4644-B675-AC4B12FEFB19"><li><p>Compute <samp class="codeph"><var>T</var> - <span class="eqsymbol">σ</span>*<span class="parmname">I</span> = <var>L</var>*<var>D</var>*<var>L</var><sup class="power"><var>T</var></sup></samp>, so that <var>L</var> and <var>D</var> define all the wanted eigenvalues to high relative accuracy. This means that small relative changes in the entries of <var>D</var> and <var>L</var> 
cause only small relative changes in the eigenvalues and eigenvectors. The standard (unfactored) representation of the tridiagonal matrix <var>T</var> does not have this property in general.</p>
</li>
<li><p>Compute the eigenvalues to suitable accuracy. If the eigenvectors are desired, the algorithm attains full accuracy of the computed eigenvalues only right before the corresponding vectors have to be computed, see Steps c) and d).</p>
</li>
<li><p>For each cluster of close eigenvalues, select a new shift close to the cluster, find a new factorization, and refine the shifted eigenvalues to suitable accuracy.</p>
</li>
<li><p>For each eigenvalue with a large enough relative separation, compute the corresponding eigenvector by forming a rank revealing twisted factorization. Go back to Step c) for any clusters that remain.</p>
</li>
</ol>
<p>The desired accuracy of the output can be specified by the input parameter <var>abstol</var>.</p>
<p>The routine <span class="option">?heevr</span> calls <a href="GUID-1180C2ED-C57A-44B7-A6DD-47CAB1AFEC66.html#GUID-1180C2ED-C57A-44B7-A6DD-47CAB1AFEC66">stemr</a> when the full spectrum is requested on machines which conform to the IEEE-754 floating point standard, or <a class="allformats" href="GUID-E7D124C0-9DAD-46E3-9AA1-5B364234D9A5.html#GUID-E7D124C0-9DAD-46E3-9AA1-5B364234D9A5">stebz</a> and <a href="GUID-0262B467-B5BB-48DF-96AA-3D03B2A48577.html#GUID-0262B467-B5BB-48DF-96AA-3D03B2A48577">stein</a> on non-IEEE machines and when partial spectrum requests are made. </p>
<p>Note that the routine <span class="option">?heevr</span> is preferable for most cases of complex Hermitian eigenvalue problems as its underlying algorithm is fast and uses less workspace.</p>
</div>
<div class="section" id="GUID-8888B1C2-2A3C-43EB-964D-8361406A2317"><h2 class="sectiontitle">Input Parameters</h2><dl id="GUID-9D5FA964-DE79-4CE2-88EF-246CC307E1BF"><dt class="dlterm"><span class="parmname">jobz</span></dt>

<dd><p><span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'N'</span> or <span class="keyword">'V'</span>. </p>
<p>If <samp class="codeph"><var>job</var> = <span class="keyword">'N'</span></samp>, then only eigenvalues are computed. </p>
<p>If <samp class="codeph"><var>job</var> = <span class="keyword">'V'</span></samp>, then eigenvalues and eigenvectors are computed.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p><span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'A'</span> or <span class="keyword">'V'</span> or <span class="keyword">'I'</span>.</p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, the routine computes all eigenvalues. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the routine computes eigenvalues <var>lambda</var><samp class="codeph">(<var>i</var>)</samp> in the half-open interval: <samp class="codeph"><var>vl</var>&lt; <var>lambda</var><samp class="codeph">(<var>i</var>)</samp><span class="eqsymbol">≤</span><var>vu</var></samp>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the routine computes eigenvalues with indices <var>il</var> to <var>iu</var>.</p>
<p>For <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>or <span class="keyword">'I'</span>, <span class="option">sstebz</span>/<span class="option">dstebz</span> and <span class="option">cstein</span>/<span class="option">zstein</span> are called.</p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p><span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>.</p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, <var>a</var> stores the upper triangular part of <var>A</var>. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, <var>a</var> stores the lower triangular part of <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span>The order of the matrix <var>A</var> (<samp class="codeph"><var>n</var><span class="eqsymbol">≥</span> 0</samp>). </p>
</dd>
<dt class="dlterm"><span class="parmname">a</span><span>, <span class="parmname">work</span></span></dt>

<dd><p><span class="keyword">COMPLEX</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zheevr</span>. </p>
<p>Arrays: </p>
<p><var>a</var><span>(<var>lda</var>,*)</span> is an array containing either upper or lower triangular part of the Hermitian matrix <var>A</var>, as specified by <var>uplo</var>. </p>
<p>The second dimension of <var>a</var> must be at least max(1, <var>n</var>).</p>
<p><var>work</var> is a workspace array, its dimension <samp class="codeph">max(1, <span class="parmname">lwork</span>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">lda</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span>The leading dimension of the array <var>a</var>.</p>
<p> Must be at least max(1, <var>n</var>).</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span>, <span class="parmname">vu</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zheevr</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the lower and upper bounds of the interval to be searched for eigenvalues. </p>
<p>Constraint: <samp class="codeph"><var>vl</var>&lt; <var>vu</var></samp>.</p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'I'</span>, <var>vl</var> and <var>vu</var> are not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span>, <span class="parmname">iu</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the indices in ascending order of the smallest and largest eigenvalues to be returned. </p>
<p>Constraint: <samp class="codeph">1 <span class="eqsymbol">≤</span><var>il</var><span class="eqsymbol">≤</span><var>iu</var><span class="eqsymbol">≤</span><var>n</var></samp>, if <samp class="codeph"><var>n</var> &gt; 0</samp>; <samp class="codeph"><var>il</var>=1</samp> and <samp class="codeph"><var>iu</var>=0</samp> if <samp class="codeph"><var>n</var> = 0</samp>.</p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'V'</span>, <var>il</var> and <var>iu</var> are not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">abstol</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zheevr</span>. </p>
<p>The absolute error tolerance to which each eigenvalue/eigenvector is required. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, the eigenvalues and eigenvectors output have residual norms bounded by <var>abstol</var>, and the dot products between different eigenvectors are bounded by <var>abstol</var>. </p>
<p>If <samp class="codeph"><var>abstol</var> &lt; <var>n</var> *eps*||<var>T</var>||</samp>, then <samp class="codeph"><var>n</var> *eps*||<var>T</var>||</samp> is used instead, where <samp class="codeph">eps</samp> is the machine precision, and <samp class="codeph">||<var>T</var>||</samp> is the 1-norm of the matrix <var>T</var>. The eigenvalues are computed to an accuracy of<samp class="codeph"> eps*||<var>T</var>||</samp> irrespective of <var>abstol</var>.
</p>
<p>If high relative accuracy is important, set <var>abstol</var> to <span class="option">?lamch</span>('S').</p>
</dd>
<dt class="dlterm"><span class="parmname">ldz</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span>The leading dimension of the output array <var>z</var>. Constraints:</p>
<p><samp class="codeph"><var>ldz</var><span class="eqsymbol">≥</span> 1</samp> if <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>;</p>
<p><samp class="codeph"><var>ldz</var><span class="eqsymbol">≥</span> max(1, <var>n</var>)</samp> if <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>The dimension of the array <var>work</var>. </p>
<p>Constraint: <samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span> max(1, 2<var>n</var>)</samp>. </p>
<p>If <samp class="codeph"><var>lwork</var> = -1</samp>, then a workspace query is assumed; the routine only calculates the optimal size of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, returns these values as the first entries of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, and no error message related to <var>lwork</var> or <var>lrwork</var> or <var>liwork</var> is issued by <a class="allformats" href="GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73.html#GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73">xerbla</a>.</p>
<p>See <em>Application Notes</em> for the suggested value of <var>lwork</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">rwork</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zheevr</span>. </p>
<p>Workspace array, size <samp class="codeph">max(1, <span class="parmname">lwork</span>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">lrwork</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>The dimension of the array <var>rwork</var>; </p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span> max(1, 24<var>n</var>)</samp>. </p>
<p>If <samp class="codeph"><var>lrwork</var> = -1</samp>, then a workspace query is assumed; the routine only calculates the optimal size of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, returns these values as the first entries of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, and no error message related to <var>lwork</var> or <var>lrwork</var> or <var>liwork</var> is issued by <a class="allformats" href="GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73.html#GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73">xerbla</a>.</p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span></dt>

<dd><p><span class="keyword">INTEGER</span>. Workspace array, its dimension <samp class="codeph">max(1, <span class="parmname">liwork</span>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">liwork</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>The dimension of the array <var>iwork</var>, </p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span> max(1, 10<var>n</var>)</samp>. </p>
<p>If <samp class="codeph"><var>liwork</var> = -1</samp>, then a workspace query is assumed; the routine only calculates the optimal size of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, returns these values as the first entries of the <var>work</var>, <var>rwork</var> and <var>iwork</var> arrays, and no error message related to <var>lwork</var> or <var>lrwork</var> or <var>liwork</var> is issued by <a class="allformats" href="GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73.html#GUID-F3536B0B-2FA0-40B4-AF9B-51A182827F73">xerbla</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-A834DEEE-6283-4D6F-81D8-23E258B1CEA4"><h2 class="sectiontitle">Output Parameters</h2><dl id="GUID-CA36853C-BBED-4E65-9D97-3BDD5A86410E"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>On exit, the lower triangle (if <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>) or the upper triangle (if <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>) of <var>A</var>, including the diagonal, is overwritten. </p>
</dd>
<dt class="dlterm"><span class="parmname">m</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span>The total number of eigenvalues found, </p>
<p><samp class="codeph">0 <span class="eqsymbol">≤</span><var>m</var><span class="eqsymbol">≤</span><var>n</var></samp>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, <samp class="codeph"><var>m</var> = <var>n</var></samp>, if <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, <samp class="codeph"><var>m</var> = <var>iu</var>-<var>il</var>+1</samp>, and if <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp> the exact value of <span class="parmname">m</span> is not known in advance.</p>
</dd>
<dt class="dlterm"><span class="parmname">w</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zheevr</span>. </p>
<p>Array, size at least max(1, <var>n</var>), contains the selected eigenvalues in ascending order, stored in <samp class="codeph"><var>w</var>(1)</samp> to <samp class="codeph"><var>w</var>(<var>m</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p><span class="keyword">COMPLEX</span> for <span class="option">cheevr</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zheevr</span>. </p>
<p>Array <var>z</var><span>(<var>ldz</var>,*)</span><span>, the second dimension of <var>z</var> must be at least max(1, <var>m</var>)</span>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, then if <samp class="codeph"><var>info</var> = 0</samp>, the first <var>m</var> columns of <var>z</var> contain the orthonormal eigenvectors of the matrix <var>A</var> corresponding to the selected eigenvalues, with the <var>i</var>-th column of <var>z</var> holding the eigenvector associated with <samp class="codeph"><var>w</var>(<var>i</var>)</samp>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then <var>z</var> is not referenced. </p>
<p>Note: you must ensure that at least max(1,<var>m</var>) columns are supplied in the array <var>z</var>; if <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the exact value of <var>m</var> is not known in advance and an upper bound must be used.</p>
</dd>
<dt class="dlterm"><span class="parmname">isuppz</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>Array, size at least 2 *max(1, <var>m</var>).</p>
<p>The support of the eigenvectors in <var>z</var>, i.e., the indices indicating the nonzero elements in <var>z</var>. The <var>i</var>-th eigenvector is nonzero only in elements <samp class="codeph"><var>isuppz</var>( 2<var>i</var>-1)</samp> through <samp class="codeph"><var>isuppz</var>( 2<var>i</var> )</samp>. Referenced only if eigenvectors are needed (<samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>) and all eigenvalues are needed, that is, <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>
 or <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>
 and <var>il</var> = 1
 and <var>iu</var> = <var>n</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">work(1)</span></dt>

<dd><p>On exit, if <samp class="codeph"><var>info</var> = 0</samp>, then <var>work(1)</var> returns the required minimal size of <var>lwork</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">rwork(1)</span></dt>

<dd><p>On exit, if <samp class="codeph"><var>info</var> = 0</samp>, then <var>rwork(1)</var> returns the required minimal size of <var>lrwork</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">iwork(1)</span></dt>

<dd><p>On exit, if <samp class="codeph"><var>info</var> = 0</samp>, then <var>iwork(1)</var> returns the required minimal size of 
<var>liwork</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p><span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>info</var> = 0</samp>, the execution is successful. </p>
<p>If <samp class="codeph"><var>info</var> = <var>-i</var></samp>, the <var>i-</var>th parameter had an illegal value. </p>
<p>If <samp class="codeph"><var>info</var> = <var>i</var></samp>, an internal error has occurred.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-E56CE447-30ED-4BBA-9AE2-EB59E1C37A3B"><h2 class="sectiontitle">LAPACK 95 Interface Notes</h2><p>Routines in Fortran 95 interface have fewer arguments in the calling sequence than their FORTRAN 77 counterparts. For general conventions applied to skip redundant or restorable arguments, see <a class="allformats" href="GUID-01F81694-7662-44A2-AE4B-7629ECD5883F.html#GUID-01F81694-7662-44A2-AE4B-7629ECD5883F">LAPACK 95 Interface Conventions</a>.</p>
<p>Specific details for the routine <span class="option">heevr</span> interface are the following:</p>
<dl id="GUID-03F5107D-4876-4454-A857-D4689AC59B09"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>Holds the matrix <var>A</var> of size (<var>n</var>, <var>n</var>).</p>
</dd>
<dt class="dlterm"><span class="parmname">w</span></dt>

<dd><p>Holds the vector of length <var>n</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p>Holds the matrix <var>Z</var> of size (<var>n</var>, <var>n</var>), where the values <var>n</var> and <var>m</var> are significant.</p>
</dd>
<dt class="dlterm"><span class="parmname">isuppz</span></dt>

<dd><p>Holds the vector of length (2*<var>n</var>), where the values (2*<var>m</var>) are significant.</p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p>Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>. The default value is <span class="keyword">'U'</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span></dt>

<dd><p>Default value for this element is <var>vl</var> = <span class="keyword">-HUGE</span>(<var>vl</var>).</p>
</dd>
<dt class="dlterm"><span class="parmname">vu</span></dt>

<dd><p>Default value for this element is <var>vu</var> = <span class="keyword">HUGE</span>(<var>vl</var>).</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span></dt>

<dd><p>Default value for this argument is <samp class="codeph"><var>il</var> = 1</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">iu</span></dt>

<dd><p>Default value for this argument is <samp class="codeph"><var>iu</var> = <var>n</var></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">abstol</span></dt>

<dd><p>Default value for this element is <var>abstol</var> = <span class="keyword">0.0_WP</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">jobz</span></dt>

<dd><p>Restored based on the presence of the argument <var>z</var> as follows: <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, if <var>z</var> is present, <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, if <var>z</var> is omitted Note that there will be an error condition if <var>isuppz</var> is present and <var>z</var> is omitted.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p>Restored based on the presence of arguments <var>vl</var>, <var>vu</var>, <var>il</var>, <var>iu</var> as follows: <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, if one of or both <var>vl</var> and <var>vu</var> are present, <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, if one of or both <var>il</var> and <var>iu</var> are present, <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, if none of <var>vl</var>, <var>vu</var>, <var>il</var>, <var>iu</var> is present, Note that there will be an error condition if one of or both <var>vl</var> and <var>vu</var> are present and at the same time one of or both <var>il</var> and <var>iu</var> are present.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-24AEB98D-64C6-4FF5-9C73-7A767500D657"><h2 class="sectiontitle">Application Notes</h2><p>For optimum performance use <samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span> (<var>nb</var>+1)*<var>n</var></samp>, where <var>nb</var> is the maximum of the blocksize for <span class="option">?hetrd</span> and <span class="option">?unmtr</span> returned by <a class="allformats" href="GUID-DD46DAED-D0DE-4B58-A602-BE1E4E7D50F1.html#GUID-DD46DAED-D0DE-4B58-A602-BE1E4E7D50F1">ilaenv</a>. </p>
<p>If you are in doubt how much workspace to supply, use a generous value of <var>lwork</var> (or <var>lrwork</var>, or <var>liwork</var>) for the first run or set  <samp class="codeph"><var>lwork</var> = -1</samp> (<samp class="codeph"><var>lrwork</var> = -1</samp>, <samp class="codeph"><var>liwork</var> = -1</samp>). </p>
<p>If 
you choose the first option and set any of admissible <var>lwork</var> (or <var>lrwork</var>, <var>liwork</var>) sizes, which is no less than the minimal value described, the routine completes the task, though probably not so fast as with a recommended workspace, and provides the recommended workspace in the first element of the corresponding array (<var>work</var>, <var>rwork</var>, <var>iwork</var>) on exit. Use this value (<samp class="codeph"><var>work</var>(1)</samp>, <samp class="codeph"><var>rwork</var>(1)</samp>, <samp class="codeph"><var>iwork</var>(1)</samp>) for subsequent runs.</p>
<p>If you set <samp class="codeph"><var>lwork</var> = -1</samp>, the routine returns immediately and provides the recommended workspace in the first element of the corresponding array (<var>work</var>, <var>rwork</var>, <var>iwork</var>). This operation is called a workspace query.</p>
<p>Note that if you set <var>lwork</var> (<var>lrwork</var>, <var>liwork</var>) to less than the minimal required value and not -1, the routine returns immediately with an error exit and does not provide any information on the recommended workspace.</p>
<p>Normal execution of <span class="option">?stemr</span> may create <samp class="codeph">NaN</samp>s and infinities and hence may abort due to a floating point exception in environments which do not handle <samp class="codeph">NaN</samp>s and infinities in the IEEE standard default manner.</p>
<p>For more details, see <a href="GUID-1180C2ED-C57A-44B7-A6DD-47CAB1AFEC66.html#GUID-1180C2ED-C57A-44B7-A6DD-47CAB1AFEC66"><span class="option">?stemr</span></a> and these references:</p>
<ul id="GUID-8EFC6A5F-B4E0-41D4-9E55-B679C86B2EF1"><li><p>Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations to compute orthogonal eigenvectors of symmetric tridiagonal matrices," Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.</p>
</li>
<li><p>Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25, 2004.  Also LAPACK Working Note 154.</p>
</li>
<li><p>Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric tridiagonal eigenvalue/eigenvector problem", Computer Science Division Technical Report No. UCB/CSD-97-971, UC Berkeley, May 1997.</p>
</li>
</ul>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-258D5408-0894-424A-83B2-33DE708A319C.html">Symmetric Eigenvalue Problems: LAPACK Driver Routines</a></div>
</div>
<div/>
</body>
</html>
