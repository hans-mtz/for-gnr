<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="p?sygvx"/>
<meta name="abstract" content="Computes selected eigenvalues and, optionally, eigenvectors of a real generalized symmetric definite eigenproblem."/>
<meta name="description" content="Computes selected eigenvalues and, optionally, eigenvectors of a real generalized symmetric definite eigenproblem."/>
<meta name="DC.subject" content="p?sygvx, ScaLAPACK routines, driver routines"/>
<meta name="keywords" content="p?sygvx, ScaLAPACK routines, driver routines"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-727B1981-9432-43FB-9EDB-35818D5218F4"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>p?sygvx</title>

</head>
<body id="GUID-727B1981-9432-43FB-9EDB-35818D5218F4">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">p?sygvx</span></h1>
<!--Computes selected eigenvalues and, optionally, eigenvectors of a real generalized symmetric definite eigenproblem.--><div><p class="shortdesc">Computes selected eigenvalues and, optionally, eigenvectors of a real generalized symmetric definite eigenproblem.</p>
<div class="section" id="GUID-6CB11C86-6ABA-4492-B961-DFEF11B08A51"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call pssygvx</span><span class="delim">(</span><span class="var">ibtype</span><span class="sep">, </span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ib</span><span class="sep">, </span><span class="var">jb</span><span class="sep">, </span><span class="var">descb</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call pdsygvx</span><span class="delim">(</span><span class="var">ibtype</span><span class="sep">, </span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ib</span><span class="sep">, </span><span class="var">jb</span><span class="sep">, </span><span class="var">descb</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-2EE543BF-CE68-4A48-8B50-F68E0D1C3200"><h2 class="sectiontitle">Include Files</h2><p/>
</div>
<div class="section" id="GUID-5D05DD7A-0575-47C5-8D5B-54A5E7304060"><h2 class="sectiontitle">Description</h2><p><span/>The <span class="option">p?sygvx</span><span>routine </span>computes all the eigenvalues, and optionally, the eigenvectors of a real generalized symmetric-definite eigenproblem, of the form </p>
<p><samp class="codeph">sub(<var>A</var>)*<var>x</var> = <span class="eqsymbol">λ</span>*sub(<var>B</var>)*<var>x</var></samp>, <samp class="codeph">sub(<var>A</var>) sub(<var>B</var>)*<var>x</var> = <span class="eqsymbol">λ*</span><var>x</var></samp>, or <samp class="codeph">sub(<var>B</var>)*sub(<var>A</var>)*<var>x</var> = <span class="eqsymbol">λ*</span><var>x</var></samp>.</p>
<p>Here    <var>x</var> denotes eigen vectors, λ (<var>lambda</var>) denotes eigenvalues,<samp class="codeph"> sub(<var>A</var>)</samp> denoting <samp class="codeph">A(<var>ia</var>:<var>ia</var>+<var>n</var>-1, <var>ja</var>:<var>ja</var>+<var>n</var>-1)</samp> is assumed to symmetric, and sub(<var>B</var>) denoting <samp class="codeph"><var>B</var>(<var>ib</var>:<var>ib</var>+<var>n</var>-1, <var>jb</var>:<var>jb</var>+<var>n</var>-1)</samp> is also positive definite. </p>
<p>
<div class="tablenoborder"><table cellpadding="4" summary="" id="d433e46" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" align="left" valign="top" width="100%" id="d829362e464"><p id="d433e52">Optimization Notice 
              </p>
</th>
</tr>
</thead>
<tbody><tr><td class="bgcolor(#f5f5f5)" bgcolor="#f5f5f5" valign="top" width="100%" headers="d829362e464 "><p>Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
              </p>
<p> Notice revision #20110804 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
 This notice covers the following instruction sets: SSE2, SSE4.2, AVX2, AVX-512. 
    </p>
</div>
<div class="section" id="GUID-8F749F87-E23C-4D92-A215-F360303822D2"><h2 class="sectiontitle">Input Parameters</h2><dl id="GUID-0028335F-0522-4A8A-9D21-441B6C5C932C"><dt class="dlterm"><span class="parmname">ibtype</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>Must be 1 or 2 or 3. </p>
<p>Specifies the problem type to be solved: </p>
<p>If <samp class="codeph"><var>ibtype</var> = 1</samp>, the problem type is  <samp class="codeph">sub(<var>A</var>)*<var>x</var> = <span class="eqsymbol"><var>lambda</var></span>*sub(<var>B</var>)<var>*x</var></samp>; </p>
<p>If <samp class="codeph"><var>ibtype</var> = 2</samp>, the problem type is <samp class="codeph">sub(<var>A</var>)*sub(<var>B</var>)<var>*x</var> = <span class="eqsymbol"><var>lambda</var></span><var>*x</var></samp>; </p>
<p>If <samp class="codeph"><var>ibtype</var> = 3</samp>, the problem type is <samp class="codeph">sub(<var>B</var>)*sub(<var>A</var>)<var>*x</var> = <span class="eqsymbol"><var>lambda</var>*</span><var>x</var></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">jobz</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'N'</span> or <span class="keyword">'V'</span>. </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword">'N'</span></samp>, then compute eigenvalues only. </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword">'V'</span></samp>, then compute eigenvalues and eigenvectors.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'A'</span> or <span class="keyword">'V'</span> or <span class="keyword">'I'</span>.</p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, the<span> routine </span>computes all eigenvalues. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the<span> routine </span>computes eigenvalues in the interval: <samp class="codeph">[<var>vl</var>, <var>vu</var>]</samp></p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the<span> routine </span>computes eigenvalues with indices <var>il</var> through <var>iu</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, arrays <var>a</var> and <var>b</var> store the upper triangles of sub(<var>A</var>) and sub (<var>B</var>);</p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, arrays <var>a</var> and <var>b</var> store the lower triangles of sub(<var>A</var>) and sub (<var>B</var>).</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The order of the matrices sub(<var>A</var>) and sub (<var>B</var>), <samp class="codeph"><var>n</var><span class="eqsymbol">≥</span> 0</samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>(local)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Pointer into the local memory to an array of size <samp class="codeph">(<var>lld_a</var>, <var>LOCc</var>(<var>ja</var>+<var>n</var>-1))</samp>. On entry, this array contains the local pieces of the <var>n</var>-by-<var>n</var> symmetric distributed matrix sub(<var>A</var>). </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, the leading <var>n</var>-by-<var>n</var> upper triangular part of sub(<var>A</var>) contains the upper triangular part of the matrix. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, the leading <var>n</var>-by-<var>n</var> lower triangular part of sub(<var>A</var>) contains the lower triangular part of the matrix. </p>
</dd>
<dt class="dlterm"><span class="parmname">ia</span>, <span class="parmname">ja</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>A</var> indicating the first row and the first column of the submatrix <var>A</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">desca</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <var>A</var>. If <samp class="codeph"><var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp> is incorrect, <span class="option">p?sygvx</span> cannot guarantee correct error reporting.</p>
</dd>
<dt class="dlterm"><span class="parmname">b</span></dt>

<dd><p>(local). <span><span class="keyword">REAL</span> for <span class="option">pssygvx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Pointer into the local memory to an array of size <samp class="codeph">(<var>lld_b</var>, <var>LOCc</var>(<var>jb</var>+<var>n</var>-1))</samp>. On entry, this array contains the local pieces of the <var>n</var>-by-<var>n</var> symmetric distributed matrix sub(<var>B</var>). </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, the leading <var>n</var>-by-<var>n</var> upper triangular part of sub(<var>B</var>) contains the upper triangular part of the matrix. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, the leading <var>n</var>-by-<var>n</var> lower triangular part of sub(<var>A</var>) contains the lower triangular part of the matrix.</p>
</dd>
<dt class="dlterm"><span class="parmname">ib</span>, <span class="parmname">jb</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>B</var> indicating the first row and the first column of the submatrix <var>B</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">descb</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <var>B</var>. <samp class="codeph"><var>descb</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp> must be equal to <samp class="codeph"><var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span>, <span class="parmname">vu</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the lower and upper bounds of the interval to be searched for eigenvalues. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'I'</span>, <var>vl</var> and <var>vu</var> are not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span>, <span class="parmname">iu</span></dt>

<dd><p>(global)</p>
<p><span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the indices in ascending order of the smallest and largest eigenvalues to be returned. Constraint: <samp class="codeph"><var>il</var> ≥ 1, min(<var>il</var>, <var>n</var>)≤ <var>iu</var> ≤ <var>n</var></samp></p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'V'</span>, <var>il</var> and <var>iu</var> are not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">abstol</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'V'</span></samp>, setting <var>abstol</var> to <span class="option">p?lamch</span>(<var>context</var>, <span class="keyword">'U'</span>) yields the most orthogonal eigenvectors. </p>
<p>The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval <samp class="codeph">[<var>a</var>,<var>b</var>]</samp> of width less than or equal to </p>
<p><samp class="codeph"><var>abstol</var> + <var>eps</var>*<span class="keyword">max</span>(|<var>a</var>|,|<var>b</var>|)</samp>, </p>
<p>where <var>eps</var> is the machine precision. If <var>abstol</var> is less than or equal to zero, then <samp class="codeph"><var>eps</var>*norm(<span class="keyword">T</span>)</samp> will be used in its place, where <samp class="codeph">norm(<span class="keyword">T</span>)</samp> is the 1-norm of the tridiagonal matrix obtained by reducing <var>A</var> to tridiagonal form. </p>
<p>Eigenvalues will be computed most accurately when <var>abstol</var> is set to twice the underflow threshold <samp class="codeph">2*<span class="option">p?lamch</span>('S')</samp> not zero. If this<span> routine </span>returns with <samp class="codeph">((<span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0)</samp> or <samp class="codeph">(<var>mod</var>(<var>info</var>/8,2)<span class="eqsymbol">≠</span>0))</samp>, indicating that some eigenvalues or eigenvectors did not converge, try setting <var>abstol</var> to <samp class="codeph">2*<span class="option">p?lamch</span>('S')</samp>. </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p><samp class="codeph">mod(<var>x</var>,<var>y</var>)</samp> is the integer remainder of <samp class="codeph"><var>x</var>/<var>y</var></samp>.</p>
</div>
</dd>
<dt class="dlterm"><span class="parmname">orfac</span></dt>

<dd><p>(global). </p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Specifies which eigenvectors should be reorthogonalized. Eigenvectors that correspond to eigenvalues which are within <samp class="codeph"><var>tol</var>=<var>orfac</var>*norm(<var>A</var>)</samp> of each other are to be reorthogonalized. However, if the workspace is insufficient (see <var>lwork</var>), <var>tol</var> may be decreased until all eigenvectors to be reorthogonalized can be stored in one process. No reorthogonalization will be done if <var>orfac</var> equals zero. A default value of 1.0e-3 is used if <var>orfac</var> is negative. <var>orfac</var> should be identical on all processes. </p>
</dd>
<dt class="dlterm"><span class="parmname">iz</span>, <span class="parmname">jz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>Z</var> indicating the first row and the first column of the submatrix <var>Z</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">descz</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <samp class="codeph"><var>Z</var>.<var>descz</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp> must equal <samp class="codeph"><var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span></dt>

<dd><p>(local)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Workspace array of size <var>lwork</var></p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Size of the array <span class="parmname">work</span>. See below for definitions of variables used to define <var>lwork</var>. </p>
<p>If no eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>), then <samp class="codeph"><var>lwork</var> ≥ 5*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <span class="keyword">NB</span>*(<var>np</var>0 + 1))</samp>. </p>
<p>If eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>), then the amount of workspace required to guarantee that all eigenvectors are computed is: </p>
<p><samp class="codeph"><var>lwork</var> ≥ 5*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <var>np</var>0*<var>mq</var>0 + 2*<var>nb</var>*<var>nb</var>) + <span class="keyword">iceil</span>(<var>neig</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)*<var>nn.</var></samp></p>
<p>The computed eigenvectors may not be orthogonal if the minimal workspace is supplied and <var>orfac</var> is too small. If you want to guarantee orthogonality at the cost of potentially poor performance you should add the following to <var>lwork</var>:</p>
<p><samp class="codeph">(<var>clustersize</var>-1)*<var>n</var></samp>,</p>
<p>where <var>clustersize</var> is the number of eigenvalues in the largest cluster, where a cluster is defined as a set of close eigenvalues: </p>
<p><samp class="codeph">{<var>w</var>(<var>k</var>),..., <var>w</var>(<var>k</var>+<var>clustersize</var>-1)|</samp><samp class="codeph"><var>w</var>(<var>j</var>+1) ≤ <var>w</var>(<var>j</var>) + <var>orfac</var>*2*norm(<var>A</var>)}</samp></p>
<p>Variable definitions: </p>
<p><var>neig</var> = number of eigenvectors requested, </p>
<p><samp class="codeph"><var>nb</var> = <var>desca</var>(<var>mb_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>mb_</var>) = <var>descz</var>(<var>nb_</var>)</samp>, </p>
<p><samp class="codeph"><var>nn</var> = <span class="keyword">max</span>(<var>n</var>, <var>nb</var>, 2)</samp>, </p>
<p><samp class="codeph"><var>desca</var>(<var>rsrc_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>rsrc_</var>) = <var>descz</var>(<var>csrc_</var>) = 0</samp>, </p>
<p><var>np</var>0 = <span class="keyword">numroc</span>(<var>nn</var>, <var>nb</var>, 0, 0, <span class="keyword">NPROW</span>), </p>
<p><var>mq</var>0 = <span class="keyword">numroc</span>(<span class="keyword">max</span>(<var>neig</var>, <var>nb</var>, 2), <var>nb</var>, 0, 0, <span class="keyword">NPCOL</span>) </p>
<p><span class="keyword">iceil</span>(<var>x</var>, <var>y</var>) is a ScaLAPACK function returning ceiling(<var>x</var>/<var>y</var>) </p>
<p> If <var>lwork</var> is too small to guarantee orthogonality, <span class="option">p?syevx</span> attempts to maintain orthogonality in the clusters with the smallest spacing between the eigenvalues. </p>
<p>If <var>lwork</var> is too small to compute all the eigenvectors requested, no computation is performed and <var>info</var>= -23 is returned. </p>
<p>Note that when <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span>,</samp> number of requested eigenvectors are not known until the eigenvalues are computed. In this case and if  <var>lwork</var> is large enough to compute the eigenvalues, <span class="option">p?sygvx</span> computes the eigenvalues and as many eigenvectors as possible.</p>
<p>Greater performance can be achieved if adequate workspace is provided. In some situations, performance can decrease as the provided workspace increases above the workspace amount shown below: </p>
<p><samp class="codeph"><var>lwork</var> ≥ <span class="keyword">max</span>(<var>lwork</var>, 5*<var>n</var> + <var>nsytrd_lwopt</var>, <var>nsygst_lwopt</var>),</samp> where</p>
<p><var>lwork</var>, as defined previously, depends upon the number of eigenvectors requested, and </p>
<p><samp class="codeph"><var>nsytrd_lwopt</var> = <var>n</var> + 2*(<var>anb</var>+1)*(4*<var>nps</var>+2) + (<var>nps</var>+3)*<var>nps</var></samp></p>
<p><samp class="codeph"><var>nsygst_lwopt</var> = 2*<var>np</var>0*<var>nb</var> + <var>nq</var>0*<var>nb</var> + <var>nb</var>*<var>nb</var></samp></p>
<p><samp class="codeph"><var>anb</var> = <span class="option">pjlaenv</span>(<var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp>, 3, <span class="option">p?syttrd</span> ', <span class="keyword">'L'</span>, 0, 0, 0, 0)</samp></p>
<p><samp class="codeph"><var>sqnpc</var> = <span class="keyword">int</span>(<var>sqrt</var>(<var>dble</var>(<span class="keyword">NPROW</span> * <span class="keyword">NPCOL</span>)))</samp></p>
<p><samp class="codeph"><var>nps</var> = <span class="keyword">max</span>(<span class="keyword">numroc</span>(<var>n</var>, 1, 0, 0, <var>sqnpc</var>), 2*<var>anb</var>)</samp></p>
<p><samp class="codeph"><span class="keyword">NB</span> = <var>desca</var><span>(<var>mb_</var>)</span></samp></p>
<p><samp class="codeph"><var>np</var>0 =<span class="keyword"> numroc</span>(<var>n</var>, <var>nb</var>, 0, 0, <span class="keyword">NPROW</span>)</samp></p>
<p><samp class="codeph"><var>nq</var>0 = <span class="keyword">numroc</span>(<var>n</var>, <var>nb</var>, 0, 0, <span class="keyword">NPCOL</span>)</samp></p>
<p><span class="keyword">numroc</span> is a ScaLAPACK tool functions; </p>
<p><span class="option">pjlaenv</span> is a ScaLAPACK environmental inquiry function </p>
<p><span class="keyword">MYROW</span>, <span class="keyword">MYCOL</span>, <span class="keyword">NPROW</span> and <span class="keyword">NPCOL</span> can be determined by calling the <span>subroutine </span><span class="keyword">blacs_gridinfo</span>. </p>
<p>For large <span class="keyword">n</span>, no extra workspace is needed, however the biggest boost in performance comes for small <span class="keyword">n</span>, so it is wise to provide the extra workspace (typically less than a Megabyte per process).</p>
<p>If <samp class="codeph"><var>clustersize</var> ≥ <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp>, then providing enough space to compute all the eigenvectors orthogonally will cause serious degradation in performance. At the limit (that is, <samp class="codeph"><var>clustersize</var> = <var>n</var>-1</samp>) <span class="option">p?stein</span> will perform no better than <span class="keyword">?stein</span> on a single processor. </p>
<p>For <samp class="codeph"><var>clustersize</var> = <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> reorthogonalizing all eigenvectors will increase the total execution time by a factor of 2 or more. </p>
<p>For <samp class="codeph"><var>clustersize</var><span class="eqsymbol">&gt;</span><var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> execution time will grow as the square of the cluster size, all other factors remaining equal and assuming enough workspace. Less workspace means less reorthogonalization but faster execution. </p>
<p>If <samp class="codeph"><samp class="codeph"><var>lwork</var> = -1</samp></samp>, then <var>lwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the size required for optimal performance for all work arrays. Each of these values is returned in the first entry of the corresponding work arrays, and no error message is issued by <span class="option">pxerbla</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>Workspace array.</p>
</dd>
<dt class="dlterm"><span class="parmname">liwork</span></dt>

<dd><p>(local) <span class="keyword">INTEGER</span>
, size of <var>iwork</var>. </p>
<p><samp class="codeph"><var>liwork</var> ≥ 6*<var>nnp</var></samp></p>
<p>Where:</p>
<p><samp class="codeph"><var>nnp</var> = <span class="keyword">max</span>(<var>n</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span> + 1, 4)</samp></p>
<p>If <var>liwork</var> = -1, then <var>liwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the minimum and optimal size for all work arrays. Each of these values is returned in the first entry of the corresponding work array, and no error message is issued by <span class="option">pxerbla</span>.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-2B711FD0-6A00-4A10-8532-14FFA8C90DB5"><h2 class="sectiontitle">Output Parameters</h2><dl id="GUID-D102A544-AE68-4D6C-8395-99497AD78AA7"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>On exit, </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, and if <samp class="codeph"><var>info</var> = 0</samp>, sub(<var>A</var>) contains the distributed matrix <var>Z</var> of eigenvectors. The eigenvectors are normalized as follows: </p>
<p>for <samp class="codeph"><var>ibtype</var> = 1 or 2</samp>, <samp class="codeph"><var> Z</var><sup class="power"><var>T</var></sup>*sub(<var>B</var>)*<var>Z</var> = <var>i</var></samp>; </p>
<p>for <samp class="codeph"><var>ibtype</var> = 3</samp>,    <samp class="codeph"><var> Z</var><sup class="power"><var>T</var></sup>*inv(sub(<var>B</var>))*<var>Z</var> = <var>i</var></samp>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then on exit the upper triangle (if <samp class="codeph"><var>uplo</var>=<span class="keyword">'U'</span></samp>) or the lower triangle (if <samp class="codeph"><var>uplo</var>=<span class="keyword">'L'</span></samp>) of sub(<var>A</var>), including the diagonal, is destroyed.</p>
</dd>
<dt class="dlterm"><span class="parmname">b</span></dt>

<dd><p>On exit, if <samp class="codeph"><var>info</var> ≤ <var>n</var></samp>, the part of sub(<var>B</var>) containing the matrix is overwritten by the triangular factor <var>U</var> or <var>L</var> from the Cholesky factorization <samp class="codeph">sub(<var>B</var>) = <var>U</var><sup class="power"><var>T</var></sup><var>*U</var> or sub(<var>B</var>) = <var>L*L</var><sup class="power"><var>T</var></sup></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">m</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The total number of eigenvalues found, <samp class="codeph">0 ≤ <var>m</var> ≤ <var>n</var></samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">nz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Total number of eigenvectors computed. <samp class="codeph">0 ≤ <var>nz</var> ≤ <var>m</var></samp>. The number of columns of <var>z</var> that are filled. </p>
<p>If <samp class="codeph"><var>jobz</var> ≠ <span class="keyword">'V'</span></samp>, <var>nz</var> is not referenced. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, <samp class="codeph"><var>nz</var> = <var>m</var></samp> unless the user supplies insufficient space and <span class="option">p?sygvx</span> is not able to detect this before beginning computation. To get all the eigenvectors requested, the user must supply both sufficient space to hold the eigenvectors in <samp class="codeph"><var>z</var> (<var>m</var><span class="eqsymbol">≤</span><var>descz</var>(<var>n_</var>))</samp> and sufficient workspace to compute them. (See <var>lwork</var> below.) <span class="option">p?sygvx</span> is always able to detect insufficient space without computation unless <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span></samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">w</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Array of size <var>n</var>. On normal exit, the first <var>m</var> entries contain the selected eigenvalues in ascending order.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p>(local). <span class="keyword"/></p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>global size <span>(<var>n</var>, <var>n</var>)</span>, local size <samp class="codeph">(<var>lld_z</var>, <var>LOCc</var>(<var>jz</var>+<var>n</var>-1))</samp>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, then on normal exit the first <var>m</var> columns of <var>z</var> contain the orthonormal eigenvectors of the matrix corresponding to the selected eigenvalues. If an eigenvector fails to converge, then that column of <var>z</var> contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in <var>ifail</var>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then <var>z</var> is not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span></dt>

<dd><p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'N'</span><var>work</var><samp class="codeph">(1)</samp></samp> = optimal amount of workspace required to compute eigenvalues efficiently </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span><var>work</var><samp class="codeph">(1)</samp></samp> = optimal amount of workspace required to compute eigenvalues and eigenvectors efficiently with no guarantee on orthogonality. </p>
<p>If <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span></samp>, it is assumed that all eigenvectors may be required. </p>
</dd>
<dt class="dlterm"><span class="parmname">ifail</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Array of size <var>n</var>. </p>
<p><var>ifail</var> provides additional information when <samp class="codeph"><var>info</var><span class="eqsymbol">≠</span>0</samp></p>
<p>If <samp class="codeph">(<var>mod</var>(<var>info</var>/16,2)<span class="eqsymbol">≠</span>0)</samp> then <samp class="codeph"><var>ifail</var><samp class="codeph">(1)</samp></samp> indicates the order of the smallest minor which is not positive definite. If <samp class="codeph">(<var>mod</var>(<var>info</var>,2)<span class="eqsymbol">≠</span>0)</samp> on exit, then <var>ifail</var> contains the indices of the eigenvectors that failed to converge.</p>
<p>If neither of the above error conditions hold and <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, then the first <var>m</var> elements of <var>ifail</var> are set to zero.</p>
</dd>
<dt class="dlterm"><span class="parmname">iclustr</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Array of size <samp class="codeph">(2*<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp>. This array contains indices of eigenvectors corresponding to a cluster of eigenvalues that could not be reorthogonalized due to insufficient workspace (see <var>lwork</var>, <var>orfac</var> and <var>info</var>). Eigenvectors corresponding to clusters of eigenvalues indexed <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">(2*<var>i</var>-1)</samp> to <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">(2*<var>i</var>)</samp>, could not be reorthogonalized due to lack of workspace. Hence the eigenvectors corresponding to these clusters may not be orthogonal. <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">()</samp> is a zero terminated array. </p>
<p><samp class="codeph">(<var>iclustr</var><span>(2*<var>k</var>)</span><span class="eqsymbol">≠</span>0.<var>and</var>. <var>iclustr</var><span>(2*<var>k</var>+1)</span>=0)</samp> if and only if <var>k</var> is the number of clusters <var>iclustr</var> is not referenced if <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">gap</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssygvx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsygvx</span>. </p>
<p>Array of size <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>. This array contains the gap between eigenvalues whose eigenvectors could not be reorthogonalized. The output values in this array correspond to the clusters indicated by the array <var>iclustr</var>. As a result, the dot product between eigenvectors corresponding to the <var>i</var>-th cluster may be as high as <samp class="codeph">(<var>C</var>*<var>n</var>)/<var>gap</var><span>(<var>i</var>)</span></samp>, where <var>C</var> is a small constant.</p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>info</var> = 0</samp>, the execution is successful. </p>
<p>If <samp class="codeph"><var>info</var> &lt;0</samp>: the <var>i</var>-th argument is an array and the <var>j-</var>entry had an illegal value, then <samp class="codeph"><var>info</var> = -(<var>i</var>*100+<var>j</var>)</samp>, if the <var>i</var>-th argument is a scalar and had an illegal value, then <samp class="codeph"><var>info</var> = -<var>i</var></samp>. </p>
<p>If <samp class="codeph"><var>info</var><span class="eqsymbol">&gt;</span> 0</samp>: </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0)</samp>, then one or more eigenvectors failed to converge. Their indices are stored in <var>ifail</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2,2)<span class="eqsymbol">≠</span>0)</samp>, then eigenvectors corresponding to one or more clusters of eigenvalues could not be reorthogonalized because of insufficient workspace. The indices of the clusters are stored in the array <var>iclustr</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/4,2)<span class="eqsymbol">≠</span>0)</samp>, then space limit prevented <span class="option">p?sygvx</span> from computing all of the eigenvectors between <var>vl</var> and <var>vu</var>. The number of eigenvectors computed is returned in <var>nz</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/8,2)<span class="eqsymbol">≠</span>0)</samp>, then <span class="option">p?stebz</span> failed to compute eigenvalues. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/16,2)<span class="eqsymbol">≠</span>0)</samp>, then <var>B</var> was not positive definite. <var>ifail(1</var>) indicates the order of the smallest minor which is not positive definite. </p>
</dd>
</dl>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html">ScaLAPACK Driver Routines</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792">Overview</a> for details of ScaLAPACK  array descriptor structures and related notations.</div></div></div>
</body>
</html>
