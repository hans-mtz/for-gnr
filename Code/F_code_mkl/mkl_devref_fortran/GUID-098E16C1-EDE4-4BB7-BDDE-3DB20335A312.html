<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="?la_porfsx_extended"/>
<meta name="abstract" content="Improves the computed solution to a system of linear equations for symmetric or Hermitian positive-definite matrices by performing extra-precise iterative refinement and provides error bounds and backward error estimates for the solution."/>
<meta name="description" content="Improves the computed solution to a system of linear equations for symmetric or Hermitian positive-definite matrices by performing extra-precise iterative refinement and provides error bounds and backward error estimates for the solution."/>
<meta name="DC.subject" content="?la_porfsx_extended, sla_porfsx_extended, dla_porfsx_extended, cla_porfsx_extended, zla_porfsx_extended, LAPACK routines, solution refinement and error estimation, refining solutions of linear equations, banded matrix, errors in solutions of linear equations, linear equations, solving, extra precise iterative refinement"/>
<meta name="keywords" content="?la_porfsx_extended, sla_porfsx_extended, dla_porfsx_extended, cla_porfsx_extended, zla_porfsx_extended, LAPACK routines, solution refinement and error estimation, refining solutions of linear equations, banded matrix, errors in solutions of linear equations, linear equations, solving, extra precise iterative refinement"/>
<meta name="DC.Relation" scheme="URI" content="GUID-118DC64D-62BB-4B91-9E76-562387E86B79.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-8CFFBC53-C9F6-428E-B486-52AB16E5E2FF.html#GUID-8CFFBC53-C9F6-428E-B486-52AB16E5E2FF"/>
<meta name="DC.Relation" scheme="URI" content="GUID-15A9E907-2600-430B-BF11-DFA0A375711B.html#GUID-15A9E907-2600-430B-BF11-DFA0A375711B"/>
<meta name="DC.Relation" scheme="URI" content="GUID-2039BD5D-44D1-487A-9B68-87BD46019A5F.html#GUID-2039BD5D-44D1-487A-9B68-87BD46019A5F"/>
<meta name="DC.Relation" scheme="URI" content="GUID-7D137664-6F3E-4832-BEDD-39EAF5AE9F52.html#GUID-7D137664-6F3E-4832-BEDD-39EAF5AE9F52"/>
<meta name="DC.Relation" scheme="URI" content="GUID-D5328149-36D0-41FF-8A5E-64EABCCD91D3.html#GUID-D5328149-36D0-41FF-8A5E-64EABCCD91D3"/>
<meta name="DC.Relation" scheme="URI" content="GUID-0538CBCD-AEDC-4AB4-A274-FB5E5C372F50.html#GUID-0538CBCD-AEDC-4AB4-A274-FB5E5C372F50"/>
<meta name="DC.Relation" scheme="URI" content="GUID-DA43ED17-684C-405D-A1A6-A210B2B5A8EE.html#GUID-DA43ED17-684C-405D-A1A6-A210B2B5A8EE"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-098E16C1-EDE4-4BB7-BDDE-3DB20335A312"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>?la_porfsx_extended</title>

</head>
<body id="GUID-098E16C1-EDE4-4BB7-BDDE-3DB20335A312">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">?la_porfsx_extended</span></h1>
<!--Improves the computed solution to a system of linear equations for symmetric or Hermitian positive-definite matrices by performing extra-precise iterative refinement and provides error bounds and backward error estimates for the solution.--><div><p class="shortdesc">Improves the computed solution to a system of linear equations for symmetric or Hermitian positive-definite matrices by performing extra-precise iterative refinement and provides error bounds and backward error estimates for the solution.</p>
<div class="section" id="GUID-7E9BF334-C34E-44E1-9EDC-16315D583ED1"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call sla_porfsx_extended</span><span class="delim">( </span><span class="var">prec_type</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">nrhs</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">af</span><span class="sep">, </span><span class="var">ldaf</span><span class="sep">, </span><span class="var">colequ</span><span class="sep">, </span><span class="var">c</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ldb</span><span class="sep">, </span><span class="var">y</span><span class="sep">, </span><span class="var">ldy</span><span class="sep">, </span><span class="var">berr_out</span><span class="sep">, </span><span class="var">n_norms</span><span class="sep">, </span><span class="var">err_bnds_norm</span><span class="sep">, </span><span class="var">err_bnds_comp</span><span class="sep">, </span><span class="var">res</span><span class="sep">, </span><span class="var">ayb</span><span class="sep">, </span><span class="var">dy</span><span class="sep">, </span><span class="var">y_tail</span><span class="sep">, </span><span class="var">rcond</span><span class="sep">, </span><span class="var">ithresh</span><span class="sep">, </span><span class="var">rthresh</span><span class="sep">, </span><span class="var">dz_ub</span><span class="sep">, </span><span class="var">ignore_cwise</span><span class="sep">, </span><span class="var">info</span><span class="delim"> )</span></p><p class="dlsyntaxpara"><span class="kwd">call dla_porfsx_extended</span><span class="delim">( </span><span class="var">prec_type</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">nrhs</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">af</span><span class="sep">, </span><span class="var">ldaf</span><span class="sep">, </span><span class="var">colequ</span><span class="sep">, </span><span class="var">c</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ldb</span><span class="sep">, </span><span class="var">y</span><span class="sep">, 
</span><span class="var">ldy</span><span class="sep">, </span><span class="var">berr_out</span><span class="sep">, </span><span class="var">n_norms</span><span class="sep">, </span><span class="var">err_bnds_norm</span><span class="sep">, </span><span class="var">err_bnds_comp</span><span class="sep">, </span><span class="var">res</span><span class="sep">, </span><span class="var">ayb</span><span class="sep">, </span><span class="var">dy</span><span class="sep">, </span><span class="var">y_tail</span><span class="sep">, </span><span class="var">rcond</span><span class="sep">, </span><span class="var">ithresh</span><span class="sep">, </span><span class="var">rthresh</span><span class="sep">, </span><span class="var">dz_ub</span><span class="sep">, </span><span class="var">ignore_cwise</span><span class="sep">, </span><span class="var">info</span><span class="delim"> )</span></p><p class="dlsyntaxpara"><span class="kwd">call cla_porfsx_extended</span><span class="delim">( </span><span class="var">prec_type</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">nrhs</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">af</span><span class="sep">, </span><span class="var">ldaf</span><span class="sep">, </span><span class="var">colequ</span><span class="sep">, </span><span class="var">c</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ldb</span><span class="sep">, </span><span class="var">y</span><span class="sep">, </span><span class="var">ldy</span><span class="sep">, </span><span class="var">berr_out</span><span class="sep">, </span><span class="var">n_norms</span><span class="sep">, </span><span class="var">err_bnds_norm</span><span class="sep">, </span><span class="var">err_bnds_comp</span><span class="sep">, </span><span class="var">res</span><span class="sep">, </span><span class="var">ayb</span><span class="sep">, </span><span class="var">dy</span><span class="sep">, </span><span class="var">y_tail</span><span class="sep">, </span><span class="var">rcond</span><span class="sep">, </span><span class="var">ithresh</span><span class="sep">, </span><span class="var">rthresh</span><span class="sep">, </span><span class="var">dz_ub</span><span class="sep">, </span><span class="var">ignore_cwise</span><span class="sep">, </span><span class="var">info</span><span class="delim"> )</span></p><p class="dlsyntaxpara"><span class="kwd">call zla_porfsx_extended</span><span class="delim">( </span><span class="var">prec_type</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">nrhs</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">af</span><span class="sep">, </span><span class="var">ldaf</span><span class="sep">, </span><span class="var">colequ</span><span class="sep">, </span><span class="var">c</span><span class="sep">, </span><span class="var">b</span><span class="sep">, </span><span class="var">ldb</span><span class="sep">, </span><span class="var">y</span><span class="sep">, 
</span><span class="var">ldy</span><span class="sep">, </span><span class="var">berr_out</span><span class="sep">, </span><span class="var">n_norms</span><span class="sep">, </span><span class="var">err_bnds_norm</span><span class="sep">, </span><span class="var">err_bnds_comp</span><span class="sep">, </span><span class="var">res</span><span class="sep">, </span><span class="var">ayb</span><span class="sep">, </span><span class="var">dy</span><span class="sep">, </span><span class="var">y_tail</span><span class="sep">, </span><span class="var">rcond</span><span class="sep">, </span><span class="var">ithresh</span><span class="sep">, </span><span class="var">rthresh</span><span class="sep">, </span><span class="var">dz_ub</span><span class="sep">, </span><span class="var">ignore_cwise</span><span class="sep">, </span><span class="var">info</span><span class="delim"> )</span></p></dl></div>
<div class="section" id="GUID-F160E17D-A12D-4154-8BC8-4E4ECD1CB0A3"><h2 class="sectiontitle">Include Files</h2><ul id="d163e82"><li id="d163e83"><span class="filepath">mkl.fi</span></li>
</ul>
</div>
<div class="section" id="GUID-9FC84754-D70A-4066-9910-877B2195389D"><h2 class="sectiontitle">Description</h2><p>The <span class="option">?la_porfsx_extended</span> subroutine improves the computed solution to a system of linear equations by performing extra-precise iterative refinement and provides error bounds and backward error estimates for the solution. The <span class="option">?herfsx</span> routine calls <span class="option">?la_porfsx_extended</span> to perform iterative refinement.</p>
<p>In addition to normwise error bound, the code provides maximum componentwise error bound, if possible. See comments for
<span class="parmname">err_bnds_norm</span> and <span class="parmname">err_bnds_comp</span> for details of the error bounds.</p>
<p>Use <span class="option">?la_porfsx_extended</span> to set only the second fields of <span class="parmname">err_bnds_norm</span> and <span class="parmname">err_bnds_comp</span>.</p>
</div>
<div class="section" id="GUID-DC973518-D74B-4D24-9736-4342CB313BDA"><h2 class="sectiontitle">Input Parameters</h2><dl id="GUID-0AEA8AB0-BCCE-4C60-B3C4-C8A4D7C11A0E"><dt class="dlterm"><span class="parmname">prec_type</span></dt>

<dd><p><span class="keyword">INTEGER</span>.</p>
<p>Specifies the intermediate precision to be used in
refinement. The value is defined by <span class="option">ilaprec(p)</span>, where <span class="parmname">p</span> is a  <span class="keyword">CHARACTER</span> and:</p>
<p>If <samp class="codeph"><span class="parmname">p</span> = <span class="keyword">'S'</span></samp>: Single.</p>
<p>If <samp class="codeph"><span class="parmname">p</span> = <span class="keyword">'D'</span></samp>: Double.</p>
<p>If <samp class="codeph"><span class="parmname">p</span> = <span class="keyword">'I'</span></samp>: Indigenous.</p>
<p>If <samp class="codeph"><span class="parmname">p</span> = <span class="keyword">'X'</span>, <span class="keyword">'E'</span></samp>: Extra.</p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p><span class="keyword">CHARACTER*1</span>.  Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>.</p>
<p>Specifies the triangle of A to store:</p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, the upper triangle of  <var>A</var> is stored,</p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, the lower triangle of  <var>A</var> is stored.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p><span class="keyword">INTEGER</span>. The number of linear equations; the order of the matrix <var>A</var>; <span class="parmname">n</span><span class="eqsymbol">≥</span> 0.</p>
</dd>
<dt class="dlterm"><span class="parmname">nrhs</span></dt>

<dd><p><span class="keyword">INTEGER</span>. The number of right-hand sides; the number of columns of the matrix <var>B</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">a, af</span><span class="parmname">, b</span>, <span class="parmname">y</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zla_porfsx_extended</span>.</p>
<p>Arrays: <samp class="codeph"><span class="parmname">a</span>(<span class="parmname">lda</span>,*)</samp>, <samp class="codeph"><span class="parmname">af</span>(<span class="parmname">ldaf</span>,*), <samp class="codeph"><span class="parmname">b</span>(<span class="parmname">ldb</span>,*)</samp>, <samp class="codeph"><span class="parmname">y</span>(<span class="parmname">ldy</span>,*)</samp></samp>.</p>
<p>The array <span class="parmname">a</span> contains the original <var>n</var>-by-<var>n</var> matrix <var>A</var>.  The second dimension of <span class="parmname">a</span> must be at least <samp class="codeph">max(1,<var>n</var>)</samp>.</p>
<p>The array <span class="parmname">af</span>  contains the triangular factor <span class="keyword">L</span> or <span class="keyword">U </span>from the Cholesky factorization as computed by <span class="option">?potrf</span>:</p>
<p><samp class="codeph">A = U<sup>T</sup>*U</samp> or <samp class="codeph">A = L*L<sup>T</sup></samp> for real flavors,</p>
<p><samp class="codeph">A = U<sup>H</sup>*U</samp> or <samp class="codeph">A = L*L<sup>H</sup></samp> for complex flavors. </p>
<p>The second dimension of <span class="parmname">af</span> must be at least <samp class="codeph">max(1,<var>n</var>)</samp>.</p>
<p>The array <span class="parmname">b</span> contains the right-hand-side of the
matrix <var>B</var>. The second dimension of <span class="parmname">b</span> must be at least <samp class="codeph">max(1,<var>nrhs</var>)</samp>.</p>
<p>The array <span class="parmname">y</span> on entry contains the solution matrix <var>X</var> as computed by <span class="option">?potrs</span>. The second dimension of <span class="parmname">y</span> must be at least <samp class="codeph">max(1,<var>nrhs</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">lda</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  The leading dimension of the array <span class="parmname">a</span>; <samp class="codeph"><span class="parmname">lda</span><span class="eqsymbol">≥</span>
		max(1,<var>n</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">ldaf</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  The leading dimension of the array <span class="parmname">af</span>; <samp class="codeph"><span class="parmname">ldaf</span><span class="eqsymbol">≥</span> max(1,<var>n</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">colequ</span></dt>

<dd><p><span class="keyword">LOGICAL</span>.  If <span class="parmname">colequ</span> =  <span class="keyword">.TRUE.</span>,   column equilibration was done to <var>A</var> before calling this routine. This is needed to compute the solution and error bounds correctly.</p>
</dd>
<dt class="dlterm"><span class="parmname">c</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p><span class="parmname">c</span> contains the column scale factors for <var>A</var>. If <span class="parmname">colequ</span> =  <span class="keyword">.FALSE.</span>, <span class="parmname">c</span> is not used.</p>
<p>If <span class="parmname">c</span> is input, each element of <span class="parmname">c</span> should be a power of the radix to ensure a reliable solution and error estimates. Scaling by power of the radix does not cause rounding errors unless the result underflows or overflows. Rounding errors during scaling lead to refining with a matrix that is not equivalent to the input matrix, producing error estimates that may not be reliable.</p>
</dd>
<dt class="dlterm"><span class="parmname">ldb</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  The leading dimension of the array <span class="parmname">b</span>; <samp class="codeph"><var>ldb</var><span class="eqsymbol">≥</span> max(1, <var>n</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">ldy</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  The leading dimension of the array <span class="parmname">y</span>; <samp class="codeph"><span class="parmname">ldy</span><span class="eqsymbol">≥</span> max(1, <var>n</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">n_norms</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  Determines which error bounds to return. See <span class="parmname">err_bnds_norm</span> and <span class="parmname">err_bnds_comp</span> descriptions in <em>Output Arguments</em> section below.</p>
<p>If <span class="parmname">n_norms</span><span class="eqsymbol">≥</span> 1, returns normwise error bounds.</p>
<p>If <span class="parmname">n_norms</span><span class="eqsymbol">≥</span> 2, returns componentwise error bounds.</p>
</dd>
<dt class="dlterm"><span class="parmname">err_bnds_norm</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Array, <span class="keyword">DIMENSION</span><samp class="codeph">(<span class="parmname">nrhs</span>,<span class="parmname">n_err_bnds</span>)</samp>. For each right-hand side, contains information about various error bounds and condition numbers corresponding to the normwise relative error.<span/></p>
<p>Normwise relative error in the <var>i</var>-th solution vector is defined as follows:</p>
<p><img src="GUID-4719B841-7B45-477A-A8ED-6C3CEF58465A-low.jpg" height="80" width="191" align="center"/></p>
<p>The array is indexed by the type of error information as described below. There are currently up to three pieces of information returned.</p>
<p>The first index in <span class="parmname">err_bnds_norm(i,:)</span>
 corresponds to the <var>i</var>-th right-hand side.</p>
<p>The second index in <span class="parmname">err_bnds_norm(:,err)</span> contains the following three fields:</p>
<table cellspacing="0" cellpadding="4" border="0" width="100%" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=1</p></td>

<td valign="top" class="noborder"><p>"Trust/don't trust" boolean. Trust the answer if the reciprocal condition number is less than the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=2</p></td>

<td valign="top" class="noborder"><p>"Guaranteed" error bound. The estimated forward error, almost certainly within a factor of 10 of the true error so long as the next entry is greater than the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>. This error bound should only be trusted if the previous boolean is true.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=3</p></td>

<td valign="top" class="noborder"><p>Reciprocal condition number. Estimated normwise reciprocal condition number. Compared with the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>
 to determine if the error estimate is "guaranteed". These reciprocal condition numbers are <samp class="codeph">1/(norm(1/z,inf)*norm(z,inf))</samp> for some appropriately scaled matrix <var>Z</var>.</p>
<p>Let <var>z</var>=<var>s</var>*<var>a</var>, where <var>s</var> scales each row by a power of the radix so all absolute row sums of <var>z</var> are approximately 1.</p>
<p>Use this subroutine to set only the second field above.</p>
</td>
</tr></table></dd>
<dt class="dlterm"><span class="parmname">err_bnds_comp</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Array, <span class="keyword">DIMENSION</span><samp class="codeph">(<span class="parmname">nrhs</span>,<span class="parmname">n_err_bnds</span>)</samp>. For each right-hand side, contains information about various error bounds and condition numbers corresponding to the componentwise relative error<span>, which is defined as follows:</span></p>
<p>Componentwise relative error in the <var>i</var>-th solution vector:</p>
<p><img src="GUID-1699C1B1-0689-411C-B381-1FC2B74210C0-low.jpg" height="66" width="191" align="center"/></p>
<p>The array is indexed by the right-hand side <var>i</var>, on which the componentwise relative error depends, and by the type of error information as described below. There are currently up to three pieces of information returned for each right-hand side. If componentwise accuracy is nit requested (<span class="parmname">params(3)</span> = 0.0), then <span class="parmname">err_bnds_comp</span> is not accessed. If <span class="parmname">n_err_bnds</span> &lt; 3, then at most the first  <span class="parmname">(:,n_err_bnds)</span> entries are returned.</p>
<p>The first index in <span class="parmname">err_bnds_comp(i,:)</span> corresponds to the <var>i</var>-th right-hand side.</p>
<p>The second index in <span class="parmname">err_bnds_comp(:,err)</span> contains the follwoing three fields:</p>
<table cellspacing="0" cellpadding="4" border="0" width="100%" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=1</p></td>

<td valign="top" class="noborder"><p>"Trust/don't trust" boolean. Trust the answer if the reciprocal condition number is less than the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=2</p></td>

<td valign="top" class="noborder"><p>"Guaranteed" error bpound. The estimated forward error, almost certainly within a factor of 10 of the true error so long as the next entry is greater than the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>. This error bound should only be trusted if the previous boolean is true.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">err</span>=3</p></td>

<td valign="top" class="noborder"><p>Reciprocal condition number. Estimated componentwise reciprocal condition number. Compared with the threshold <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>slamch</var>(<span class="eqsymbol">ε</span>)</samp> for <span class="option">sla_porfsx_extended/cla_porfsx_extended</span> and <samp class="codeph"><var>sqrt</var>(<var>n</var>)*<var>dlamch</var>(<span class="eqsymbol">ε</span>)</samp>
for <span class="option">dla_porfsx_extended/zla_porfsx_extended</span>
 to determine if the error estimate is "guaranteed". These reciprocal condition numbers are <samp class="codeph">1/(norm(1/z,inf)*norm(z,inf))</samp> for some appropriately scaled matrix <var>Z</var>.</p>
<p>Let <samp class="codeph"><var>z</var>=<var>s</var>*(<var>a</var>*diag(<var>x</var>))</samp>, where <var>x</var> is the solution for the current right-hand side and <var>s</var> scales each row of <samp class="codeph"><var>a</var>*diag(<var>x</var>)</samp> by a power of the radix so all absolute row sums of <var>z</var> are approximately 1.</p>
<p>Use this subroutine to set only the second field above.</p>
</td>
</tr></table></dd>
<dt class="dlterm"><span class="parmname">res</span>, <span class="parmname">dy</span>, <span class="parmname">y_tail</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zla_porfsx_extended</span>.</p>
<p>Workspace arrays of <span class="keyword">DIMENSION</span><var>n</var>.</p>
<p><span class="parmname">res</span> holds the intermediate residual.</p>
<p><span class="parmname">dy</span> holds the intermediate solution.</p>
<p><span class="parmname">y_tail</span> holds the trailing bits of the intermediate solution.</p>
</dd>
<dt class="dlterm"><span class="parmname">ayb</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Workspace array, <span class="keyword">DIMENSION</span><var>n</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">rcond</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Reciprocal scaled condition number. An estimate of the reciprocal Skeel condition number of the matrix <var>A</var> after equilibration (if done). If <span class="parmname">rcond</span> is less than the machine precision, in particular, if <span class="parmname">rcond</span> = 0, the matrix is singular to working precision. Note that the error may still be small even if this number is very small and the matrix appears ill-conditioned.</p>
</dd>
<dt class="dlterm"><span class="parmname">ithresh</span></dt>

<dd><p><span class="keyword">INTEGER</span>.  The maximum number of residual computations allowed for refinement. The default is 10. For 'aggressive', set to 100 to permit convergence using approximate factorizations or factorizations other than LU. If the factorization uses a technique other than Gaussian elimination, the guarantees in  <span class="parmname">err_bnds_norm</span> and <span class="parmname">err_bnds_comp</span> may no longer be trustworthy.</p>
</dd>
<dt class="dlterm"><span class="parmname">rthresh</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Determines when to stop refinement if the error estimate stops decreasing. Refinement stops when the next solution no longer satisfies</p>
<p><samp class="codeph">norm(dx_{<var>i</var>+1}) &lt; <span class="parmname">rthresh</span> * norm(dx_<var>i</var>)</samp></p>
<p>where <samp class="codeph">norm(<var>z</var>)</samp> is the infinity norm of <var>Z</var>. </p>
<p><span class="parmname">rthresh</span> satisfies</p>
<p><samp class="codeph">0 &lt; <span class="parmname">rthresh</span><span class="eqsymbol">≤</span> 1</samp>.</p>
<p>The default value is 0.5. For 'aggressive' set to 0.9 to permit convergence on extremely ill-conditioned matrices.</p>
</dd>
<dt class="dlterm"><span class="parmname">dz_ub</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Determines when to start considering componentwise convergence. Componentwise <span class="parmname">dz_ub</span> convergence is only considered after each component of the solution <var>y</var> is stable, that is, the relative change in each component is less than <span class="parmname">dz_ub</span>. The default value is 0.25, requiring the first bit to be stable.</p>
</dd>
<dt class="dlterm"><span class="parmname">ignore_cwise</span></dt>

<dd><p><span class="keyword">LOGICAL</span></p>
<p>If <span class="keyword">.TRUE.</span>, the function ignores componentwise convergence. Default value is <span class="keyword">.FALSE.</span></p>
</dd>
</dl>
</div>
<div class="section" id="GUID-F64D7910-6724-44D7-A428-9E7F6A31C57F"><h2 class="sectiontitle">Output Parameters</h2><dl id="GUID-EA01572E-14EB-4669-8DCC-36D212912C5A"><dt class="dlterm"><span class="parmname">y</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zla_porfsx_extended</span>.</p>
<p>The improved solution matrix <var>Y</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">berr_out</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sla_porfsx_extended</span> and  <span class="option">cla_porfsx_extended</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dla_porfsx_extended</span> and <span class="option">zla_porfsx_extended</span>.</p>
<p>Array, <span class="keyword">DIMENSION</span><samp class="codeph"><var>nrhs</var></samp>. <span class="parmname">berr_out(j)</span>
contains the componentwise relative backward error for right-hand-side  <var>j</var> from the formula</p>
<p><samp class="codeph">max(<var>i</var>) ( abs(<span class="parmname">res</span>(<var>i</var>)) / ( abs(op(<var>A</var><sub/>))*abs(<var>y</var>)  +  abs(<var>B</var><sub/>) )(<var>i</var>) )</samp></p>
<p>where <samp class="codeph">abs(<var>z</var>)</samp> is the componentwise absolute value of the matrix or vector <var>Z</var>. This is computed by <span class="option">?la_lin_berr</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">err_bnds_norm</span>, <span class="parmname">err_bnds_comp</span></dt>

<dd><p>Values of the corresponding input parameters improved after iterative refinement and stored in the second column of the array <samp class="codeph">( 1:<span class="parmname">nrhs</span>, 2 )</samp>. The other elements are kept unchanged.</p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p><span class="keyword">INTEGER</span>. If <samp class="codeph"><span class="parmname">info</span> = 0</samp>, the execution is successful. The solution to every right-hand side is guaranteed.</p>
<p>If <samp class="codeph"><span class="parmname">info</span> = <var>-i</var></samp>, the <var>i</var>-th parameter had an illegal value. </p>
</dd>
</dl>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-118DC64D-62BB-4B91-9E76-562387E86B79.html">LAPACK Auxiliary Routines</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-8CFFBC53-C9F6-428E-B486-52AB16E5E2FF.html#GUID-8CFFBC53-C9F6-428E-B486-52AB16E5E2FF"><span class="option">?porfsx</span></a> </div>
<div><a href="GUID-15A9E907-2600-430B-BF11-DFA0A375711B.html#GUID-15A9E907-2600-430B-BF11-DFA0A375711B"><span class="option">?potrf</span></a> </div>
<div><a href="GUID-2039BD5D-44D1-487A-9B68-87BD46019A5F.html#GUID-2039BD5D-44D1-487A-9B68-87BD46019A5F"><span class="option">?potrs</span></a> </div>
<div><a href="GUID-7D137664-6F3E-4832-BEDD-39EAF5AE9F52.html#GUID-7D137664-6F3E-4832-BEDD-39EAF5AE9F52"><span class="option">?lamch</span></a> </div>
<div><a href="GUID-D5328149-36D0-41FF-8A5E-64EABCCD91D3.html#GUID-D5328149-36D0-41FF-8A5E-64EABCCD91D3"><span class="option">ilaprec</span></a> </div>
<div><a href="GUID-0538CBCD-AEDC-4AB4-A274-FB5E5C372F50.html#GUID-0538CBCD-AEDC-4AB4-A274-FB5E5C372F50"><span class="option">ilatrans</span></a> </div>
<div><a href="GUID-DA43ED17-684C-405D-A1A6-A210B2B5A8EE.html#GUID-DA43ED17-684C-405D-A1A6-A210B2B5A8EE"><span class="option">?la_lin_berr</span></a> </div></div></div>
</body>
</html>
