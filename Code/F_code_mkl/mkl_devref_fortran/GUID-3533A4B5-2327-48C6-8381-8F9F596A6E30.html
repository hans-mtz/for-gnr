<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="p?heevx"/>
<meta name="abstract" content="Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix."/>
<meta name="description" content="Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix."/>
<meta name="DC.subject" content="p?heevx, ScaLAPACK routines, driver routines, Hermitian matrix, eigenvalues and eigenvectors"/>
<meta name="keywords" content="p?heevx, ScaLAPACK routines, driver routines, Hermitian matrix, eigenvalues and eigenvectors"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-3533A4B5-2327-48C6-8381-8F9F596A6E30"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>p?heevx</title>

</head>
<body id="GUID-3533A4B5-2327-48C6-8381-8F9F596A6E30">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">p?heevx</span></h1>
<!--Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix.--><div><p class="shortdesc">Computes selected eigenvalues and, optionally, eigenvectors of a Hermitian matrix.</p>
<div class="section" id="GUID-0466CB72-CD17-4C8E-BEB4-267F36CE8537"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call pcheevx</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">lrwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call pzheevx</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">lrwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-C5942F99-0EE7-4181-A7E0-980BD65B0705"><h2 class="sectiontitle">Include Files</h2><p/>
</div>
<div class="section" id="GUID-F615EAD0-4007-407F-B105-56DF5F6E3323"><h2 class="sectiontitle">Description</h2><p><span/>The <span class="option">p?heevx</span><span> routine </span>computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix <var>A</var> by calling the recommended sequence of ScaLAPACK <span>routines</span>. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<p>
<div class="tablenoborder"><table cellpadding="4" summary="" id="d433e46" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" align="left" valign="top" width="100%" id="d409515e334"><p id="d433e52">Optimization Notice 
              </p>
</th>
</tr>
</thead>
<tbody><tr><td class="bgcolor(#f5f5f5)" bgcolor="#f5f5f5" valign="top" width="100%" headers="d409515e334 "><p>Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
              </p>
<p> Notice revision #20110804 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
 This notice covers the following instruction sets: SSE2, SSE4.2, AVX2, AVX-512. 
    </p>
</div>
<div class="section" id="GUID-53FF8819-493A-47AC-942B-C760B171E614"><h2 class="sectiontitle">Input Parameters</h2><p><var>np</var> = the number of rows local to a given process. </p>
<p><var>nq</var> = the number of columns local to a given process. </p>
<dl id="GUID-0CED80B9-D5E4-4522-AF01-61B7C0EC58D4"><dt class="dlterm"><span class="parmname">jobz</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'N'</span> or <span class="keyword">'V'</span>. </p>
<p>Specifies if it is necessary to compute the eigenvectors: </p>
<p>If <samp class="codeph"><span class="parmname">jobz</span> = <span class="keyword">'N'</span></samp>, then only eigenvalues are computed. </p>
<p>If <samp class="codeph"><span class="parmname">jobz</span> = <span class="keyword">'V'</span></samp>, then eigenvalues and eigenvectors are computed.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'A'</span>, <span class="keyword">'V'</span>, or <span class="keyword">'I'</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, all eigenvalues will be found. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, all eigenvalues in the half-open interval <samp class="codeph">[<var>vl</var>, <var>vu</var>]</samp> will be found. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the eigenvalues with indices <var>il</var> through <var>iu</var> will be found. </p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>.</p>
<p>Specifies whether the upper or lower triangular part of the Hermitian matrix <var>A</var> is stored: </p>
<p>If <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'U'</span></samp>, <span class="parmname">a</span> stores the upper triangular part of <var>A</var>. </p>
<p>If <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'L'</span></samp>, <span class="parmname">a</span> stores the lower triangular part of <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The number of rows and columns of the matrix <var>A</var><samp class="codeph">(<var>n</var><span class="eqsymbol">≥</span> 0)</samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>(local). </p>
<p><span class="keyword">COMPLEX</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">pzheevx</span>. </p>
<p>Block cyclic array of global size <span>(<var>n</var>, <var>n</var>)</span> and local size <samp class="codeph">(<var>lld_a</var>, <var>LOC</var><var>c</var>(<var>ja</var>+<var>n</var>-1))</samp>. On entry, the Hermitian matrix <var>A</var>. </p>
<p>If <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'U'</span></samp>, only the upper triangular part of <var>A</var> is used to define the elements of the Hermitian matrix.</p>
<p>If <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'L'</span></samp>, only the lower triangular part of <var>A</var> is used to define the elements of the Hermitian matrix. </p>
</dd>
<dt class="dlterm"><span class="parmname">ia</span>, <span class="parmname">ja</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>A</var> indicating the first row and the first column of the submatrix <var>A</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">desca</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <var>A</var>. If <samp class="codeph"><var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp> is incorrect, <span class="option">p?heevx</span> cannot guarantee correct error reporting.</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span>, <span class="parmname">vu</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the lower and upper bounds of the interval to be searched for eigenvalues; not referenced if <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'I'</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span>, <span class="parmname">iu</span></dt>

<dd><p>(global)</p>
<p><span><span class="keyword">INTEGER</span>. </span>If <samp class="codeph"><var>range</var> =<span class="keyword">'I'</span></samp>, the indices of the smallest and largest eigenvalues to be returned. </p>
<p>Constraints: </p>
<p><samp class="codeph"><var>il</var> ≥ 1; </samp><samp class="codeph">min(<var>il</var>,<var>n</var>) ≤ <var>iu</var> ≤ <var>n</var></samp>.</p>
<p>Not referenced if <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'V'</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">abstol</span></dt>

<dd><p>(global). </p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>. </p>
<p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'V'</span></samp>, setting <var>abstol</var> to <span class="option">p?lamch</span>(<var>context</var>, <span class="keyword">'U'</span>) yields the most orthogonal eigenvectors. </p>
<p>The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval <samp class="codeph">[<var>a</var>, <var>b</var>]</samp> of width less than or equal to <samp class="codeph"><var>abstol</var>+<var>eps</var>*max(|<var>a</var>|,|<var>b</var>|)</samp>, where <var>eps</var> is the machine precision. If <var>abstol</var> is less than or equal to zero, then <samp class="codeph"><var>eps</var>*norm(<span class="keyword">T</span>)</samp> will be used in its place, where <samp class="codeph">norm(<span class="keyword">T</span>)</samp> is the 1-norm of the tridiagonal matrix obtained by reducing <var>A</var> to tridiagonal form. </p>
<p>Eigenvalues are computed most accurately when <var>abstol</var> is set to twice the underflow threshold <samp class="codeph">2*<span class="option">p?lamch</span>('S')</samp>, not zero. If this<span> routine </span>returns with <samp class="codeph">((<span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0).<var>or</var>.(<span class="keyword">mod</span>(<var>info</var>/8,2)<span class="eqsymbol">≠</span>0))</samp>, indicating that some eigenvalues or eigenvectors did not converge, try setting <var>abstol</var> to <samp class="codeph">2*<span class="option">p?lamch</span>('S')</samp>. </p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p><samp class="codeph">mod(<var>x</var>,<var>y</var>)</samp> is the integer remainder of <samp class="codeph"><var>x</var>/<var>y</var></samp>.</p>
</div>
</dd>
<dt class="dlterm"><span class="parmname">orfac</span></dt>

<dd><p>(global). <span><span class="keyword">REAL</span> for <span class="option">pcheevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>. </p>
<p>Specifies which eigenvectors should be reorthogonalized. Eigenvectors that correspond to eigenvalues which are within <var>tol</var>=<var>orfac</var>*norm(<var>A</var>) of each other are to be reorthogonalized. However, if the workspace is insufficient (see <var>lwork</var>), <var>tol</var> may be decreased until all eigenvectors to be reorthogonalized can be stored in one process. No reorthogonalization will be done if <var>orfac</var> equals zero. A default value of 1.0e-3 is used if <var>orfac</var> is negative. </p>
<p><var>orfac</var> should be identical on all processes. </p>
</dd>
<dt class="dlterm"><span class="parmname">iz</span>, <span class="parmname">jz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>Z</var> indicating the first row and the first column of the submatrix <var>Z</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">descz</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <var>Z</var>. <samp class="codeph"><span class="parmname">descz</span><span>( <var>ctxt_</var> )</span></samp> must equal <var>desca</var><span>( <var>ctxt_</var> )</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span></dt>

<dd><p>(local).</p>
<p><span class="keyword">COMPLEX</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">pzheevx</span>. </p>
<p>Array of size <var>lwork</var>. </p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>The size of the array <var>work</var>. </p>
<p>If only eigenvalues are requested: </p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span><var>n</var> + <span class="keyword">max</span>(<var>nb</var>*(<var>np</var>0 + 1), 3)</samp></p>
<p>If eigenvectors are requested: </p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span><var>n</var> + (<var>np</var>0+<var>mq</var>0+<var>nb</var>)*<var>nb</var></samp></p>
<p>with <samp class="codeph"><var>nq</var>0 = <span class="keyword">numroc</span>(<var>nn</var>, <var>nb</var>, 0, 0, <span class="keyword">NPCOL</span>)</samp>.</p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span> 5*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <var>np</var>0*<var>mq</var>0+2*<var>nb</var>*<var>nb</var>) + <span class="keyword">iceil</span>(<var>neig</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)*<var>nn</var></samp></p>
<p>For optimal performance, greater workspace is needed, that is</p>
<p><samp class="codeph"><var>lwork</var><span class="eqsymbol">≥</span><span class="keyword">max</span>(<var>lwork</var>, <var>nhetrd_lwork</var>) </samp></p>
<p>where <var>lwork</var> is as defined above, and <samp class="codeph"><var>nhetrd_lwork</var> =  <var>n</var> + 2*(<var>anb</var>+1)*(4*<var>nps</var>+2) + (<var>nps</var>+1)*<var>nps</var></samp></p>
<p><samp class="codeph"><var>ictxt</var> = <var>desca</var><samp class="codeph">(<var>ctxt_</var>)</samp></samp></p>
<p><samp class="codeph"><var>anb</var> = <span class="option">pjlaenv</span>(<var>ictxt</var>, 3, '<span class="option">pchettrd</span>', <span class="keyword">'L</span>', 0, 0, 0, 0)</samp></p>
<p><samp class="codeph"><var>sqnpc</var> = <var>sqrt</var>(<var>dble</var>(<span class="keyword">NPROW</span> * <span class="keyword">NPCOL</span>))</samp></p>
<p><samp class="codeph"><var>nps</var> = <span class="keyword">max</span>(<span class="keyword">numroc</span>(<var>n</var>, 1, 0, 0, <var>sqnpc</var>), 2*<var>anb</var>)</samp></p>
<p>If <samp class="codeph"><var>lwork</var> = -1</samp>, then <var>lwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the size required for optimal performance for all work arrays. Each of these values is returned in the first entry of the corresponding work arrays, and no error message is issued by <span class="option">pxerbla</span>. </p>
</dd>
<dt class="dlterm"><span class="parmname">rwork</span></dt>

<dd><p>(local)</p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>. </p>
<p>Workspace array of size <var>lrwork</var>. </p>
</dd>
<dt class="dlterm"><span class="parmname">lrwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>The size of the array <var>work</var>. </p>
<p>See below for definitions of variables used to define <var>lwork</var>. </p>
<p>If no eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>),  then <samp class="codeph"><var>lrwork</var><span class="eqsymbol">≥</span> 5*<var>nn</var>+4*<var>n.</var></samp></p>
<p>If eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>),  then the amount of workspace required to guarantee that all eigenvectors are computed is: </p>
<p><samp class="codeph"><var>lrwork</var><span class="eqsymbol">≥</span> 4*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <var>np</var>0*<var>mq</var>0+2*<var>nb</var>*<var>nb</var>) + <span class="keyword">iceil</span>(<var>neig</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)*<var>nn</var></samp></p>
<p>The computed eigenvectors may not be orthogonal if the minimal workspace is supplied and <var>orfac</var> is too small. If you want to guarantee orthogonality (at the cost of potentially poor performance) you should add the following values to <var>lrwork</var>:</p>
<p><samp class="codeph">(<var>clustersize</var>-1)*<var>n</var></samp>,</p>
<p>where <var>clustersize</var> is the number of eigenvalues in the largest cluster, where a cluster is defined as a set of close eigenvalues: </p>
<p><samp class="codeph">{<var>w</var>(<var>k</var>),..., <var>w</var>(<var>k</var>+<var>clustersize</var>-1)|</samp><samp class="codeph"><var>w</var>(<var>j</var>+1) ≤ <var>w</var>(<var>j</var>)+<var>orfac</var>*2*norm(<var>A</var>)}. </samp></p>
<p> Variable definitions: </p>
<p><var>neig</var> = number of eigenvectors requested;</p>
<p><samp class="codeph"><var>nb</var> = <var>desca</var>(<var>mb_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>mb_</var>) = <var>descz</var>(<var>nb_</var>)</samp>; </p>
<p><samp class="codeph"><var>nn</var> = <span class="keyword">max</span>(<var>n</var>, <span class="keyword">NB</span>, 2)</samp>; </p>
<p><samp class="codeph"><var>desca</var>(<var>rsrc_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>rsrc_</var>) = <var>descz</var>(<var>csrc_</var>) = 0</samp>; </p>
<p><samp class="codeph"><var>np</var>0 = <span class="keyword">numroc</span>(<var>nn</var>, <var>nb</var>, 0, 0, <span class="keyword">NPROW</span>);</samp></p>
<p><samp class="codeph"><var>mq</var>0 = <span class="keyword">numroc</span>(<span class="keyword">max</span>(<var>neig</var>, <var>nb</var>, 2), <var>nb</var>, 0, 0, <span class="keyword">NPCOL</span>);</samp></p>
<p><samp class="codeph"><span class="keyword">iceil</span>(<var>x</var>, <var>y</var>)</samp> is a ScaLAPACK function returning ceiling(<var>x</var>/<var>y</var>) </p>
<p> When <var>lrwork</var> is too small: </p>
<p>If <var>lwork</var> is too small to guarantee orthogonality, <span class="option">p?heevx</span> attempts to maintain orthogonality in the clusters with the smallest spacing between the eigenvalues. If <var>lwork</var> is too small to compute all the eigenvectors requested, no computation is performed and <var>info</var>= -23 is returned. Note that when <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span></samp>, <span class="option">p?heevx</span> does not know how many eigenvectors are requested until the eigenvalues are computed. Therefore, when <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span></samp> and as long as <var>lwork</var> is large enough to allow <span class="option">p?heevx</span>  to compute the eigenvalues, <span class="option">p?heevx</span> will compute the eigenvalues and as many eigenvectors as it can.</p>
<p>Relationship between workspace, orthogonality and performance: </p>
<p>If <samp class="codeph"><var>clustersize</var> ≥ <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp>, then providing enough space to compute all the eigenvectors orthogonally will cause serious degradation in performance. In the limit (that is, <samp class="codeph"><var>clustersize</var> = <var>n</var>-1)</samp><a class="allformats" href="GUID-AD6C57C2-B53E-49FF-B9C5-8AC33A289150.html#GUID-AD6C57C2-B53E-49FF-B9C5-8AC33A289150"><span class="option">p?stein</span></a> will perform no better than <span class="keyword">?stein</span> on 1 processor. </p>
<p>For <samp class="codeph"><var>clustersize</var> = <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> reorthogonalizing all eigenvectors will increase the total execution time by a factor of 2 or more. </p>
<p>For <samp class="codeph"><var>clustersize</var><span class="eqsymbol">&gt;</span><var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> execution time will grow as the square of the cluster size, all other factors remaining equal and assuming enough workspace. Less workspace means less reorthogonalization but faster execution. </p>
<p>If <samp class="codeph"><var>lwork</var> = -1</samp>, then <var>lwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the size required for optimal performance for all work arrays. Each of these values is returned in the first entry of the corresponding work arrays, and no error message is issued by <span class="option">pxerbla</span>. </p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>Workspace array.</p>
</dd>
<dt class="dlterm"><span class="parmname">liwork</span></dt>

<dd><p>(local)<span class="keyword"> INTEGER</span>, size of <span class="parmname">iwork</span>.</p>
<p><samp class="codeph"><var>liwork</var> ≥ 6*<var>nnp</var></samp></p>
<p>Where: <samp class="codeph"><var>nnp</var> = <span class="keyword">max</span>(<var>n</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>+1, 4)</samp></p>
<p>If <samp class="codeph"><var>liwork</var> = -1</samp>, then <var>liwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the minimum and optimal size for all work arrays. Each of these values is returned in the first entry of the corresponding work array, and no error message is issued by <span class="option">pxerbla</span>.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-D7CA018B-38B2-44C6-A388-0A2C21261AD8"><h2 class="sectiontitle">Output Parameters</h2><dl id="GUID-3F66BF22-EE28-4346-8721-5D9DD9AC3F62"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>On exit, the lower triangle (if <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'L'</span></samp>), or the upper triangle (if <samp class="codeph"><span class="parmname">uplo</span> = <span class="keyword">'U'</span></samp>) of <var>A</var>, including the diagonal, is overwritten.</p>
</dd>
<dt class="dlterm"><span class="parmname">m</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The total number of eigenvalues found; <samp class="codeph">0 ≤ <var>m</var> ≤  <var>n</var></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">nz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>Total number of eigenvectors computed. <samp class="codeph">0 ≤ <var>nz</var> ≤ <var>m</var></samp>.</p>
<p>The number of columns of <var>z</var> that are filled. </p>
<p>If <samp class="codeph"><var>jobz</var> ≠ <span class="keyword">'V'</span></samp>, <var>nz</var> is not referenced. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, <samp class="codeph"><var>nz</var> = <var>m</var></samp> unless the user supplies insufficient space and <span class="option">p?heevx</span> is not able to detect this before beginning computation. To get all the eigenvectors requested, the user must supply both sufficient space to hold the eigenvectors in <samp class="codeph"><var>z</var> (<var>m</var><span class="eqsymbol">≤</span><var>descz</var><span>(<var>n_</var>)</span>)</samp> and sufficient workspace to compute them. (See <var>lwork</var>). <span class="option">p?heevx</span> is always able to detect insufficient space without computation unless <var>range</var>=<span class="keyword">'V'</span>. </p>
</dd>
<dt class="dlterm"><span class="parmname">w</span></dt>

<dd><p>(global). </p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>.</p>
<p>Array of size <var>n</var>. The first <var>m</var> elements contain the selected eigenvalues in ascending order.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p>(local). </p>
<p><span class="keyword">COMPLEX</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">pzheevx</span>.</p>
<p>Array, global size <span>(<var>n</var>, <var>n</var>)</span>, local size <samp class="codeph">(<var>lld_z</var>, <var>LOCc</var>(<var>jz</var>+<var>n</var>-1))</samp>.</p>
<p>If <samp class="codeph"><span class="parmname">jobz</span> =<span class="keyword">'V'</span></samp>, then on normal exit the first <var>m</var> columns of <span class="parmname">z</span> contain the orthonormal eigenvectors of the matrix corresponding to the selected eigenvalues. If an eigenvector fails to converge, then that column of <var>z</var> contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in <var>ifail</var>.</p>
<p>If <samp class="codeph"><span class="parmname">jobz</span> = <span class="keyword">'N'</span></samp>, then <span class="parmname">z</span> is not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span><samp class="codeph">(1)</samp></dt>

<dd><p>On exit, returns adequate workspace to allow optimal performance.</p>
</dd>
<dt class="dlterm"><span class="parmname">rwork</span></dt>

<dd><p>(local).</p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>.</p>
<p>Array of size <var>lrwork</var>. On return, <var>rwork</var><samp class="codeph">(1)</samp> contains the optimal amount of workspace required for efficient execution. </p>
<p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'N'</span><var>rwork</var><samp class="codeph">(1)</samp></samp> = optimal amount of workspace required to compute eigenvalues efficiently. </p>
<p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'V'</span><var>rwork</var><samp class="codeph">(1)</samp></samp> = optimal amount of workspace required to compute eigenvalues and eigenvectors efficiently with no guarantee on orthogonality. </p>
<p>If <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span></samp>, it is assumed that all eigenvectors may be required. </p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span><samp class="codeph">(1)</samp></dt>

<dd><p>(local)</p>
<p>On return, <span class="parmname">iwork</span><samp class="codeph">(1)</samp> contains the amount of integer workspace required.</p>
</dd>
<dt class="dlterm"><span class="parmname">ifail</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Array of size <var>n</var>. </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword">'V'</span></samp>, then on normal exit, the first <var>m</var> elements of <var>ifail</var> are zero. If (<samp class="codeph"><span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0</samp>) on exit, then <var>ifail</var> contains the indices of the eigenvectors that failed to converge. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then <var>ifail</var> is not referenced. </p>
</dd>
<dt class="dlterm"><span class="parmname">iclustr</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>Array of size 2*<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>. </p>
<p>This array contains indices of eigenvectors corresponding to a cluster of eigenvalues that could not be reorthogonalized due to insufficient workspace (see <var>lwork</var>, <var>orfac</var> and <var>info</var>). Eigenvectors corresponding to clusters of eigenvalues indexed <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">(2*<var>i</var>-1)</samp> to <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">(2*<var>i</var>)</samp>, could not be reorthogonalized due to lack of workspace. Hence the eigenvectors corresponding to these clusters may not be orthogonal. <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">()</samp> is a zero terminated array. <samp class="codeph">(<var>iclustr</var></samp><samp class="codeph">(2*<var>k</var>)</samp><samp class="codeph"><span class="eqsymbol">≠</span>0</samp> and <samp class="codeph"><var>iclustr</var></samp><samp class="codeph">(2*<var>k</var>+1)</samp><samp class="codeph">=0)</samp> if and only if <var>k</var> is the number of clusters. <var>iclustr</var> is not referenced if <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">gap</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pcheevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pzheevx</span>.</p>
<p>Array of size <samp class="codeph">(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp></p>
<p>This array contains the gap between eigenvalues whose eigenvectors could not be reorthogonalized. The output values in this array correspond to the clusters indicated by the array <var>iclustr</var>. As a result, the dot product between eigenvectors corresponding to the <var>i</var>-th cluster may be as high as <samp class="codeph">(<var>C</var>*<var>n</var>)/<var>gap</var>(<var>i</var>)</samp> where <var>C</var> is a small constant. </p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><span class="parmname">info</span> = 0</samp>, the execution is successful.</p>
<p>If <samp class="codeph"><span class="parmname">info</span> &lt; 0</samp>: </p>
<p>If the <var>i</var>-th argument is an array and the <var>j</var>-entry had an illegal value, then <samp class="codeph"><span class="parmname">info</span> = -(<var>i</var>*100+<var>j</var>)</samp>. If the <var>i</var>-th argument is a scalar and had an illegal value, then <samp class="codeph"><span class="parmname">info</span> = -<var>i</var></samp>. </p>
<p>If <samp class="codeph"><span class="parmname">info</span><span class="eqsymbol">&gt;</span> 0</samp>:</p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0)</samp>, then one or more eigenvectors failed to converge. Their indices are stored in <var>ifail</var>. Ensure <samp class="codeph"><var>abstol</var>=2.0*<span class="option">p?lamch</span>(<span class="keyword">'U'</span>)</samp></p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/2,2)<span class="eqsymbol">≠</span>0)</samp>, then eigenvectors corresponding to one or more clusters of eigenvalues could not be reorthogonalized because of insufficient workspace.The indices of the clusters are stored in the array <var>iclustr</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/4,2)<span class="eqsymbol">≠</span>0)</samp>, then space limit prevented <a class="allformats" href="GUID-0E684CCB-0D14-4DBB-8EDE-BE9A8B499D94.html#GUID-0E684CCB-0D14-4DBB-8EDE-BE9A8B499D94"><span class="option">p?syevx</span></a> from computing all of the eigenvectors between <var>vl</var> and <var>vu</var>. The number of eigenvectors computed is returned in <var>nz</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/8,2)<span class="eqsymbol">≠</span>0)</samp>, then <a href="GUID-E362299B-F0FA-47C6-98CF-9D1F9A56CE65.html#GUID-E362299B-F0FA-47C6-98CF-9D1F9A56CE65"><span class="option">p?stebz</span></a> failed to compute eigenvalues. Ensure <samp class="codeph"><var>abstol</var>=2.0*<span class="option">p?lamch</span>(<span class="keyword">'U'</span>)</samp>.</p>
</dd>
</dl>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html">ScaLAPACK Driver Routines</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792">Overview</a> for details of ScaLAPACK  array descriptor structures and related notations.</div></div></div>
</body>
</html>
