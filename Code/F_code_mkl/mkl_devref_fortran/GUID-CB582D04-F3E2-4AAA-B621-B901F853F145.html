<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="?gesvdx"/>
<meta name="abstract" content="Computes the SVD and left and right singular vectors for a matrix."/>
<meta name="description" content="Computes the SVD and left and right singular vectors for a matrix."/>
<meta name="DC.subject" content="sgesvdx, dgesvdx, cgesvdx, zgesvdx"/>
<meta name="keywords" content="sgesvdx, dgesvdx, cgesvdx, zgesvdx"/>
<meta name="DC.Relation" scheme="URI" content="GUID-BDA281B1-921F-4A41-B381-DCD341B0774A.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-CB582D04-F3E2-4AAA-B621-B901F853F145"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>?gesvdx</title>

</head>
<body id="GUID-CB582D04-F3E2-4AAA-B621-B901F853F145">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">?gesvdx</span></h1>
<!-- Computes  the SVD and left and right singular vectors for a matrix.--><div><p class="shortdesc"> Computes  the SVD and left and right singular vectors for a matrix.</p>
<div class="section" id="GUID-AB1A6E6F-86E7-4DC4-B49C-E28296423718"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call sgesvdx</span><span class="delim">(</span><span class="var">jobu</span><span class="sep">, </span><span class="var">jobvt</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">ns</span><span class="sep">, </span><span class="var">s</span><span class="sep">, </span><span class="var">u</span><span class="sep">, </span><span class="var">ldu</span><span class="sep">, </span><span class="var">vt</span><span class="sep">, </span><span class="var">ldvt</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call dgesvdx</span><span class="delim">(</span><span class="var">jobu</span><span class="sep">, </span><span class="var">jobvt</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">ns</span><span class="sep">, </span><span class="var">s</span><span class="sep">, </span><span class="var">u</span><span class="sep">, </span><span class="var">ldu</span><span class="sep">, </span><span class="var">vt</span><span class="sep">, </span><span class="var">ldvt</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call cgesvdx</span><span class="delim">(</span><span class="var">jobu</span><span class="sep">, </span><span class="var">jobvt</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">ns</span><span class="sep">, </span><span class="var">s</span><span class="sep">, </span><span class="var">u</span><span class="sep">, </span><span class="var">ldu</span><span class="sep">, </span><span class="var">vt</span><span class="sep">, </span><span class="var">ldvt</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call zgesvdx</span><span class="delim">(</span><span class="var">jobu</span><span class="sep">, </span><span class="var">jobvt</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">lda</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">ns</span><span class="sep">, </span><span class="var">s</span><span class="sep">, </span><span class="var">u</span><span class="sep">, </span><span class="var">ldu</span><span class="sep">, </span><span class="var">vt</span><span class="sep">, </span><span class="var">ldvt</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">rwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-37FF83B4-B600-4CB5-A32B-239AD001603C"><h2 class="sectiontitle">Include Files</h2><ul id="d163e88"><li id="d163e89"><span class="filepath">mkl.fi</span></li>
</ul>
</div>
<div class="section" id="GUID-7A8E9990-72D4-42DB-AABA-88D873F4D016"><h2 class="sectiontitle">Description</h2><p><span class="option">?gesvdx</span> computes the singular value decomposition (SVD) of a real or complex m-by-n matrix <var>A</var>, optionally computing the left and right singular vectors. The SVD is written</p>
<p><var>A</var> = <var>U</var> * <var class="varname">Σ</var> * transpose(<var>V</var>)</p>
<p>where <var class="varname">Σ</var> is an <span class="parmname">m</span>-by-<span class="parmname">n</span> matrix which is zero except for its min(<span class="parmname">m</span>,<span class="parmname">n</span>) diagonal elements, <var>U</var> is an <span class="parmname">m</span>-by-<span class="parmname">m</span> matrix, and <var>V</var> is an <span class="parmname">n</span>-by-<span class="parmname">n</span> matrix. The matrices <var>U</var> and <var>V</var> are orthogonal for real <var>A</var>, and unitary for complex <var>A</var>. The diagonal elements of <var class="varname">Σ</var> are the singular values of <var>A</var>; they are real and non-negative, and are returned in descending order. The first min(<span class="parmname">m</span>,<span class="parmname">n</span>) columns of <var>U</var> and <var>V</var> are the left and right singular vectors of <var>A</var>.</p>
<p><span class="option">?gesvdx</span> uses an eigenvalue problem for obtaining the SVD, which allows for the computation of a subset of singular values and vectors. See <a href="GUID-9ED7B9A9-E7F8-462B-88FE-01F364BFC8D1.html#GUID-9ED7B9A9-E7F8-462B-88FE-01F364BFC8D1"><span class="option">?bdsvdx</span></a> for details.</p>
<p>Note that the routine returns <var>V</var><sup>T</sup>, not <var>V</var>.</p>
</div>
<div class="section" id="GUID-637F13B0-FF0F-482F-B91A-DCB6ABD969F0"><h2 class="sectiontitle">Input Parameters</h2><dl id="GUID-C797C7E8-B08E-4458-B189-37D9EFA806BF"><dt class="dlterm"><span class="parmname">jobu</span></dt>

<dd><p><span>CHARACTER*1. </span>Specifies options for computing all or part of the matrix <var>U</var>:</p>
<p>= 'V': the first min(<span class="parmname">m</span>,<span class="parmname">n</span>) columns of <var>U</var> (the left singular vectors) or as specified by <span class="parmname">range</span> are returned in the array <span class="parmname">u</span>;</p>
<p>= 'N': no columns of <var>U</var> (no left singular vectors) are computed.</p>
</dd>
<dt class="dlterm"><span class="parmname">jobvt</span></dt>

<dd><p><span>CHARACTER*1. </span>Specifies options for computing all or part of the matrix <var>V</var><sup>T</sup>:</p>
<p>= 'V': the first min(<span class="parmname">m</span>,<span class="parmname">n</span>) rows of <var>V</var><sup>T</sup> (the right singular vectors) or as specified by <span class="parmname">range</span> are returned in the array <span class="parmname">vt</span>;</p>
<p>= 'N': no rows of <var>V</var><sup>T</sup> (no right singular vectors) are computed.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p><span>CHARACTER*1. </span>= 'A': find all singular values.</p>
<p>= 'V': all singular values in the half-open interval (<span class="parmname">vl</span>,<span class="parmname">vu</span>] are found.</p>
<p>= 'I': the <span class="parmname">il</span>-th through <span class="parmname">iu</span>-th singular values are found.</p>
</dd>
<dt class="dlterm"><span class="parmname">m</span></dt>

<dd><p><span>INTEGER. </span>The number of rows of the input matrix <var>A</var>.  <span class="parmname">m</span><span class="eqsymbol">≥</span> 0.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p><span>INTEGER. </span>The number of columns of the input matrix <var>A</var>.  <span class="parmname">n</span><span class="eqsymbol">≥</span> 0.</p>
</dd>
<dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zgesvdx</span></p>
<p>Array, size <span>(<span class="parmname">lda</span>,<span class="parmname">n</span>)</span></p>
<p>On entry, the <span class="parmname">m</span>-by-<span class="parmname">n</span> matrix <var>A</var>. </p>
</dd>
<dt class="dlterm"><span class="parmname">lda</span></dt>

<dd><p><span>INTEGER. </span>The leading dimension of the array <span class="parmname">a</span>.</p>
<p><span class="parmname">lda</span><span class="eqsymbol">≥</span> max(1,<span class="parmname">m</span>).</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">REAL</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zgesvdx</span></p>
<p><span class="parmname">vl</span><span class="eqsymbol">≥</span>0.</p>
</dd>
<dt class="dlterm"><span class="parmname">vu</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">REAL</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zgesvdx</span></p>
<p>If <span class="parmname">range</span>='V', the lower and upper bounds of the interval to be searched for singular values. <span class="parmname">vu</span> &gt; <span class="parmname">vl</span>. Not referenced if <span class="parmname">range</span> = 'A' or 'I'.</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span></dt>

<dd><p><span>INTEGER. </span></p>
</dd>
<dt class="dlterm"><span class="parmname">iu</span></dt>

<dd><p><span>INTEGER. </span>If <span class="parmname">range</span>='I', the indices (in ascending order) of the smallest and largest singular values to be returned. 1 <span class="eqsymbol">≤</span><span class="parmname">il</span><span class="eqsymbol">≤</span><span class="parmname">iu</span><span class="eqsymbol">≤</span> min(<span class="parmname">m</span>,<span class="parmname">n</span>), if min(<span class="parmname">m</span>,<span class="parmname">n</span>) &gt; 0. Not referenced if <span class="parmname">range</span> = 'A' or 'V'.</p>
</dd>
<dt class="dlterm"><span class="parmname">ldu</span></dt>

<dd><p><span>INTEGER. </span>The leading dimension of the array <span class="parmname">u</span>. <span class="parmname">ldu</span><span class="eqsymbol">≥</span> 1; if <span class="parmname">jobu</span> = 'V', <span class="parmname">ldu</span><span class="eqsymbol">≥</span><span class="parmname">m</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">ldvt</span></dt>

<dd><p><span>INTEGER. </span>The leading dimension of the array <span class="parmname">vt</span>. <span class="parmname">ldvt</span><span class="eqsymbol">≥</span> 1; if <span class="parmname">jobvt</span> = 'V', <span class="parmname">ldvt</span><span class="eqsymbol">≥</span><span class="parmname">ns</span> (see above).</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zgesvdx</span></p>
<p>Array, size (max(1,<span class="parmname">lwork</span>)).</p>
<p>On exit, if info = 0, <span class="parmname">work</span>(1) returns the optimal <span class="parmname">lwork</span>;</p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p><span>INTEGER. </span>The size of the array <span class="parmname">work</span>.</p>
<p><span class="parmname">lwork</span><span class="eqsymbol">≥</span> max(1, min(<span class="parmname">m</span>, <span class="parmname">n</span>)*(min(<span class="parmname">m</span>, <span class="parmname">n</span>) + 4)) for the paths (see comments inside the code):</p>
<ul id="GUID-A1B758B9-279B-49D2-8C16-043C24A56860"><li><p>PATH 1 (<span class="parmname">m</span> much larger than <span class="parmname">n</span>)</p>
</li>
<li><p>PATH 1t (<span class="parmname">n</span> much larger than <span class="parmname">m</span>)</p>
</li>
</ul>
<p><span class="parmname">lwork</span><span class="eqsymbol">≥</span> max(1, min(<span class="parmname">m</span>, <span class="parmname">n</span>)*2 + max(<span class="parmname">m</span>, <span class="parmname">n</span>)) for the other paths. For good performance, <span class="parmname">lwork</span> should generally be larger.</p>
<p>If <span class="parmname">lwork</span> = -1, then a workspace query is assumed; the routine only calculates the optimal size of the <span class="parmname">work</span> array, returns this value as the first entry of the <span class="parmname">work</span> array, and no error message related to <span class="parmname">lwork</span> is issued by <span class="option">xerbla</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">rwork</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zgesvdx</span></p>
<p>Array, size (max(1, <var>lrwork</var>)).</p>
<p><var>lrwork</var><span class="eqsymbol">≥</span> min(<span class="parmname">m</span>, <span class="parmname">n</span>)*(min(<span class="parmname">m</span>, <span class="parmname">n</span>)*2 + 15*min(<span class="parmname">m</span>, <span class="parmname">n</span>)).</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-692DA09B-2D77-43FE-AED6-F3CA76C71CB4"><h2 class="sectiontitle">Output Parameters</h2><table cellspacing="0" cellpadding="4" border="0" width="90%" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">a</span></p></td>

<td valign="top" class="noborder"><p>On exit, the contents of <span class="parmname">a</span> are destroyed.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">ns</span></p></td>

<td valign="top" class="noborder"><p><span>INTEGER. </span>The total number of singular values found,</p>
<p>0 <span class="eqsymbol">≤</span><span class="parmname">ns</span><span class="eqsymbol">≤</span> min(<span class="parmname">m</span>, <span class="parmname">n</span>).</p>
<p>If <span class="parmname">range</span> = 'A', <span class="parmname">ns</span> = min(<span class="parmname">m</span>, <span class="parmname">n</span>); if <span class="parmname">range</span> = 'I', <span class="parmname">ns</span> = <span class="parmname">iu</span> - <span class="parmname">il</span> + 1.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">s</span></p></td>

<td valign="top" class="noborder"><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">REAL</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">zgesvdx</span></p>
<p>Array, size (min(<span class="parmname">m</span>,<span class="parmname">n</span>))</p>
<p>The singular values of <var>A</var>, sorted so that <samp class="codeph"><span class="parmname">s</span>(<var>i</var>)</samp><span class="eqsymbol">≥</span><samp class="codeph"><span class="parmname">s</span>(<var>i</var> + 1)</samp>.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">u</span></p></td>

<td valign="top" class="noborder"><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zgesvdx</span></p>
<p>If <span class="parmname">jobu</span> = 'V', <span class="parmname">u</span> contains columns of <var>U</var> (the left singular vectors, stored columnwise) as specified by <span class="parmname">range</span>; if <span class="parmname">jobu</span> = 'N', <span class="parmname">u</span> is not referenced.</p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Make sure that <var>ucol</var><span class="eqsymbol">≥</span><span class="parmname">ns</span>; if <span class="parmname">range</span> = 'V', the exact value of <span class="parmname">ns</span> is not known in advance and an upper bound must be used.</p>
</div>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">vt</span></p></td>

<td valign="top" class="noborder"><p><span class="keyword">REAL</span> for <span class="option">sgesvdx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">dgesvdx</span></p>
<p><span class="keyword">COMPLEX</span> for <span class="option">cgesvdx</span></p>
<p><span class="keyword">DOUBLE COMPLEX</span> for <span class="option">zgesvdx</span></p>
<p>Array, size <span>(<span class="parmname">ldvt</span>,<span class="parmname">n</span>)</span></p>
<p>If <span class="parmname">jobvt</span> = 'V', <span class="parmname">vt</span> contains the rows of <var>V</var><sup>T</sup> (the right singular vectors, stored rowwise) as specified by <span class="parmname">range</span>; if <span class="parmname">jobvt</span> = 'N', <span class="parmname">vt</span> is not referenced.</p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p>Make sure that <span class="parmname">ldvt</span><span class="eqsymbol">≥</span><span class="parmname">ns</span>; if <span class="parmname">range</span> = 'V', the exact value of <span class="parmname">ns</span> is not known in advance and an upper bound must be used.</p>
</div>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">iwork</span></p></td>

<td valign="top" class="noborder"><p><span>INTEGER. </span>Array, size (12*min(<span class="parmname">m</span>, <span class="parmname">n</span>)).</p>
<p>If <span class="parmname">info</span> = 0, the first <span class="parmname">ns</span> elements of <span class="parmname">superb</span> are zero. If <span class="parmname">info</span> &gt; 0, then <span class="parmname">superb</span> contains the indices of the eigenvectors that failed to converge in <span class="option">?bdsvdx</span>/<span class="option">?stevx</span>.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="parmname">info</span></p></td>

<td valign="top" class="noborder"><p><span class="keyword">INTEGER</span>.</p>
<p>= 0: successful exit.</p>
<p>&lt; 0: if info = -<var>i</var>, the <var>i</var>-th argument had an illegal value.</p>
<p>&gt; 0: if info = <var>i</var>, then <var>i</var> eigenvectors failed to converge in <span class="option">?bdsvdx</span>/<span class="option">?stevx</span>. if info = <span class="parmname">n</span>*2 + 1, an internal error occurred in <span class="option">?bdsvdx</span>.</p>
</td>
</tr></table></div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-BDA281B1-921F-4A41-B381-DCD341B0774A.html">Singular Value Decomposition: LAPACK Driver Routines</a></div>
</div>
<div/>
</body>
</html>
