<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="p?laqr1"/>
<meta name="abstract" content="Sets a scalar multiple of the first column of the product of a 2-by-2 or 3-by-3 matrix and specified shifts."/>
<meta name="description" content="Sets a scalar multiple of the first column of the product of a 2-by-2 or 3-by-3 matrix and specified shifts."/>
<meta name="DC.subject" content="pslaqr1, ScaLAPACK routines, auxiliary routines, pdlaqr1, Hessenberg matrix"/>
<meta name="keywords" content="pslaqr1, ScaLAPACK routines, auxiliary routines, pdlaqr1, Hessenberg matrix"/>
<meta name="DC.Relation" scheme="URI" content="GUID-BF7438B3-BB55-478A-88DB-33C01481F990.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-92F38ECF-79CA-4D58-8331-E1C38B7775C6"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>p?laqr1</title>

</head>
<body id="GUID-92F38ECF-79CA-4D58-8331-E1C38B7775C6">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">p?laqr1</span></h1>
<!--Sets a scalar multiple of the first column of the product of a 2-by-2 or 3-by-3 matrix and specified shifts.--><div><p class="shortdesc">Sets a scalar multiple of the first column of the product of a 2-by-2 or 3-by-3 matrix and specified shifts.</p>
<div class="section" id="GUID-840072CD-773B-43B4-A65D-BEF59CC30DBA"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call pslaqr1</span><span class="delim">(</span><span class="var"> wantt</span><span class="sep">, </span><span class="var">wantz</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">ilo</span><span class="sep">, </span><span class="var">ihi</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">wr</span><span class="sep">, </span><span class="var">wi</span><span class="sep">, </span><span class="var">iloz</span><span class="sep">, </span><span class="var">ihiz</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">ilwork</span><span class="sep">, </span><span class="var">info </span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call pdlaqr1</span><span class="delim">(</span><span class="var"> wantt</span><span class="sep">, </span><span class="var">wantz</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">ilo</span><span class="sep">, </span><span class="var">ihi</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">wr</span><span class="sep">, </span><span class="var">wi</span><span class="sep">, </span><span class="var">iloz</span><span class="sep">, </span><span class="var">ihiz</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">ilwork</span><span class="sep">, </span><span class="var">info </span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-44EFA0FF-2AB5-4B1C-8477-ECE546C700E3"><h2 class="sectiontitle">Description</h2><p><span class="option">p?laqr1</span> is an auxiliary <span>routine </span>used to find the Schur decomposition and/or eigenvalues of a matrix already in Hessenberg form from columns <span class="parmname">ilo</span> to <span class="parmname">ihi</span>. </p>
<p>This is a modified version of <a href="GUID-DCE20F5B-BC48-496B-9CCB-8FD537CB4510.html"><span class="option">p?lahqr</span></a> from ScaLAPACK version 1.7.3. The following modifications were made: </p>
<ul id="GUID-EAC882A0-EA7B-4C47-9F8E-85431E09F4CD"><li><p>Workspace query functionality was added. </p>
</li>
<li><p>Aggressive early deflation is implemented. </p>
</li>
<li><p>Aggressive deflation (looking for two consecutive small subdiagonal elements by PSLACONSB) is abandoned.</p>
</li>
<li><p>The returned Schur form is now in canonical form, i.e., the returned 2-by-2 blocks really correspond to complex conjugate pairs of eigenvalues. </p>
</li>
<li><p>For some reason, the original version of <span class="option">p?lahqr</span> sometimes did not read out the converged eigenvalues correctly. This is now fixed. </p>
</li>
</ul>
<p>
<div class="tablenoborder"><table cellpadding="4" summary="" id="d433e46" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" align="left" valign="top" width="100%" id="d1085602e255"><p id="d433e52">Optimization Notice 
              </p>
</th>
</tr>
</thead>
<tbody><tr><td class="bgcolor(#f5f5f5)" bgcolor="#f5f5f5" valign="top" width="100%" headers="d1085602e255 "><p>Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
              </p>
<p> Notice revision #20110804 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
 This notice covers the following instruction sets: SSE2, SSE4.2, AVX2, AVX-512. 
    </p>
</div>
<div class="section" id="GUID-5A03A85B-3EED-479E-8399-07F2186F2DE1"><h2 class="sectiontitle">Input Parameters</h2><dl id="GUID-01970A4A-6494-4168-9CC7-CFB80DD1ADC1"><dt class="dlterm"><span class="parmname">wantt</span></dt>

<dd><p>(global ) <span class="keyword">LOGICAL</span></p>
<p><span class="keyword">= .TRUE.</span> : the full Schur form <var>T</var> is required;</p>
<p><span class="keyword">= .FALSE.</span>: only eigenvalues are required.</p>
</dd>
<dt class="dlterm"><span class="parmname">wantz</span></dt>

<dd><p>(global ) LOGICAL</p>
<p><span class="keyword">= .TRUE.</span> : the matrix of Schur vectors <var>Z</var> is required;</p>
<p><span class="keyword">= .FALSE.</span>: Schur vectors are not required.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p>(global ) <span class="keyword">LOGICAL</span></p>
<p>The order of the Hessenberg matrix <var>A </var> (and <var>Z</var> if <span class="parmname">wantz</span>). <span class="parmname">n</span><span class="eqsymbol">≥</span> 0.</p>
</dd>
<dt class="dlterm"><span class="parmname">ilo</span>, <span class="parmname">ihi</span></dt>

<dd><p>(global ) <span class="option">INTEGER</span></p>
<p>It is assumed that the matrix <var>A</var>  is already upper quasi-triangular in rows and columns <span class="parmname">ihi</span>+1:<span class="parmname">n</span>, and that A(<span class="parmname">ilo</span>,<span class="parmname">ilo</span>-1) = 0 (unless <span class="parmname">ilo</span> = 1). <span class="option">p?laqr1</span> works primarily with the Hessenberg submatrix in rows and columns <span class="parmname">ilo</span> to <span class="parmname">ihi</span>, but applies transformations to all of <var>H</var> if <span class="parmname">wantt</span> is <span><span class="keyword">.TRUE.</span></span>.</p>
<p>1 <span class="eqsymbol">≤</span><span class="parmname">ilo</span><span class="eqsymbol">≤</span> max(1,<span class="parmname">ihi</span>); <span class="parmname">ihi</span><span class="eqsymbol">≤</span><span class="parmname">n</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">pslaqr1</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdlaqr1</span></p>
<p>(global ) array of size <span>(<var>lld_a</var>,<span><var>LOC</var><sub><var>c</var></sub></span>(<span class="parmname">n</span>))</span></p>
<p>On entry, the upper Hessenberg matrix <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">desca</span></dt>

<dd><p>(global and local ) <span class="option">INTEGER</span> array of size <var>dlen_</var>.</p>
<p>The array descriptor for the distributed matrix <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">iloz</span>, <span class="parmname">ihiz</span></dt>

<dd><p>(global ) <span class="option">INTEGER</span></p>
<p>Specify the rows of the matrix <var>Z</var> to which transformations must be applied if <span class="parmname">wantz</span> is <span><span class="keyword">.TRUE.</span></span>.</p>
<p>1 <span class="eqsymbol">≤</span><span class="parmname">iloz</span><span class="eqsymbol">≤</span><span class="parmname">ilo</span>; <span class="parmname">ihi</span><span class="eqsymbol">≤</span><span class="parmname">ihiz</span><span class="eqsymbol">≤</span><span class="parmname">n</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">pslaqr1</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdlaqr1</span></p>
<p>(global ) array of size <span>(<var>lld_z</var>,<span><var>LOC</var><sub><var>c</var></sub></span>(<span class="parmname">n</span>))</span>.</p>
<p>If <span class="parmname">wantz</span> is <span><span class="keyword">.TRUE.</span></span>, on entry <span class="parmname">z</span> must contain the current matrix <var>Z</var> of transformations accumulated by <a href="GUID-B863D4DF-2BC6-4E9F-863E-84D4BC7839C5.html"><span class="option">p?hseqr</span></a></p>
<p>If <span class="parmname">wantz</span> is <span><span class="keyword">.FALSE.</span></span>, <span class="parmname">z</span> is not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">descz</span></dt>

<dd><p>(global and local ) <span class="option">INTEGER</span> array of size <var>dlen_</var>.</p>
<p>The array descriptor for the distributed matrix <var>Z</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname"> work</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">pslaqr1</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdlaqr1</span></p>
<p>(local output) array of size  <span class="parmname">lwork</span></p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p>(local ) <span class="option">INTEGER</span></p>
<p> The size of the work array
(<span class="parmname">lwork</span>&gt;=1).</p>
<p> If <span class="parmname">lwork</span>=-1, then a workspace query is
assumed. </p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span></dt>

<dd><p>(global and local ) <span class="option">INTEGER</span> array of size  <span class="parmname">ilwork</span></p>
<p>This holds the some of the IBLK integer arrays.  </p>
</dd>
<dt class="dlterm"><span class="parmname">ilwork</span></dt>

<dd><p>(local ) <span class="option">INTEGER</span></p>
<p> The size of the <span class="parmname">iwork</span> array (<span class="parmname">ilwork</span><span class="eqsymbol">≥</span> 3 ).</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-30662C2D-75DB-442A-9727-578773EFC065"><h2 class="sectiontitle">OUTPUT Parameters</h2><dl id="GUID-B5818565-EE85-4A22-BFDF-CB3045518740"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>If <span class="parmname">wantt</span> is <span><span class="keyword">.TRUE.</span></span>, <span class="parmname"/>the matrix <var>A</var>  is upper quasi-triangular in rows and columns <span class="parmname">ilo</span>:<span class="parmname">ihi</span>, with any 2-by-2 or larger diagonal blocks not yet in standard form. If <span class="parmname">wantt</span><span>is <span class="keyword">.FALSE.</span></span>, the contents of <span class="parmname">a</span> are unspecified on exit.</p>
</dd>
<dt class="dlterm"><span class="parmname">wr</span>, <span class="parmname">wi</span></dt>

<dd><p><span class="keyword">REAL</span> for <span class="option">pslaqr1</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdlaqr1</span></p>
<p>(global replicated )  array of size <span class="parmname">n</span></p>
<p>The real and imaginary parts, respectively, of the computed eigenvalues <span class="parmname">ilo</span> to <span class="parmname">ihi</span> are stored in the corresponding elements of <span class="parmname">wr</span> and <span class="parmname">wi</span>. If two eigenvalues are computed as a complex conjugate pair, they are stored in consecutive elements of <span class="parmname">wr</span> and <span class="parmname">wi</span>, say the <var>i</var>-th and (<var>i</var>+1)th, with <span><span class="parmname">wi</span>(<var>i</var>) &gt; 0 and <span class="parmname">wi</span>(<var>i</var>+1) &lt; 0</span>. If <span class="parmname">wantt</span> is <span><span class="keyword">.TRUE.</span></span>, the eigenvalues are stored in the same order as on the diagonal of the Schur form returned in <span class="parmname">a</span>.  <span class="parmname">a</span> may be returned with larger diagonal blocks until the next release.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p>On exit <span class="parmname">z</span> is updated; transformations are applied only to the submatrix <var>Z</var>(<span class="parmname">iloz</span>:<span class="parmname">ihiz</span>,<span class="parmname">ilo</span>:<span class="parmname">ihi</span>).</p>
<p>If <span class="parmname">wantz</span><span>is <span class="keyword">.FALSE.</span></span>, <span class="parmname">z</span> is not referenced.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span><span>(1)</span></dt>

<dd><p> On exit, if <span class="parmname">info</span> = 0, <span class="parmname">work</span><span>(1)</span> returns the optimal <span class="parmname">lwork</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p>(global ) <span class="option">INTEGER</span></p>
<p>&lt; 0: parameter number -<span class="parmname">info</span> incorrect or inconsistent</p>
<p>= 0: successful exit</p>
<p>&gt; 0: <span class="option">p?laqr1</span> failed to compute all the eigenvalues <span class="parmname">ilo</span> to <span class="parmname">ihi</span> in a total of 30*(<span class="parmname">ihi</span>-<span class="parmname">ilo</span>+1) iterations; if <span class="parmname">info</span> = <var>i</var>, elements <span><var>i</var>+1:<span class="parmname">ihi</span></span> of <span class="parmname">wr</span> and <span class="parmname">wi</span> contain those eigenvalues which have been successfully computed.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-8E51CD9C-481F-4557-B7D4-45BAF1CCEA9F"><h2 class="sectiontitle">Application Notes</h2><p>This algorithm is very similar to <a href="GUID-DCE20F5B-BC48-496B-9CCB-8FD537CB4510.html"><span class="option">p?ahqr</span></a>.  Unlike <span class="option">p?lahqr</span>, instead of sending one double shift through the largest unreduced submatrix, this algorithm sends multiple double shifts and spaces them apart so that there can be parallelism across several processor row/columns.  Another critical difference is that this algorithm aggregrates multiple transforms together in order to apply them in a block fashion. </p>
<p>Current Notes and/or Restrictions:</p>
<ul id="GUID-9CBAE4D4-C5AB-4FE3-9CB9-92BC447C361D"><li><p> This code requires the distributed block size to be square and at least six (6); unlike simpler codes like LU, this algorithm is extremely sensitive to block size.  Unwise choices of too small a block size can lead to bad performance. </p>
</li>
<li><p>This code requires <span class="parmname">a</span> and <span class="parmname">z</span> to be distributed identically and have identical contxts. </p>
</li>
<li><p>This release currently does not have a <span>routine </span>for resolving the Schur blocks into regular 2x2 form after this code is completed.  Because of this, a significant performance impact is required while the deflation is done by sometimes a single column of processors. </p>
</li>
<li><p>This code does not currently block the initial transforms so that none of the rows or columns for any bulge are completed until all are started.  To offset pipeline start-up it is recommended that at least 2*LCM(NPROW,NPCOL) bulges are used (if possible) </p>
</li>
<li><p>The maximum number of bulges currently supported is fixed at 32.  In future versions this will be limited only by the incoming <span class="parmname"> work</span> array.</p>
</li>
<li><p>The matrix <var>A </var> must be in upper Hessenberg form.  If elements below the subdiagonal are nonzero, the resulting transforms may be nonsimilar.  This is also true with the LAPACK <span>routine</span>. </p>
</li>
<li><p>For this release, it is assumed <var>rsrc_</var>=<var>csrc_</var>=0 </p>
</li>
<li><p>Currently, all the eigenvalues are distributed to all the nodes.  Future releases will probably distribute the eigenvalues by the column partitioning. </p>
</li>
<li><p>The internals of this <span>routine </span>are subject to change. </p>
</li>
</ul>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-BF7438B3-BB55-478A-88DB-33C01481F990.html">ScaLAPACK Auxiliary Routines</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792">Overview</a> for details of ScaLAPACK  array descriptor structures and related notations.</div></div></div>
</body>
</html>
