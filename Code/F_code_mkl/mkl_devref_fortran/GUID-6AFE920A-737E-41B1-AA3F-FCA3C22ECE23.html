<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="topic"/>
<meta name="DC.Title" content="Glossary"/>
<meta name="DC.Coverage" content=""/>
<meta name="DC.Relation" scheme="URI" content="GUID-0191F247-778C-4C69-B54F-ABF951506FCD.html"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="prodname" content="Intel&reg; oneAPI Math Kernel Library"/>
<meta name="version" content="0.8"/>
<meta name="series" content=""/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-6AFE920A-737E-41B1-AA3F-FCA3C22ECE23"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>Glossary</title>

</head>
<body id="GUID-6AFE920A-737E-41B1-AA3F-FCA3C22ECE23">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1">Glossary</h1>
<div><table cellspacing="0" cellpadding="4" border="0" width="90%" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" width="30%" class="noborder"><p><var class="varname">A</var><sup class="power"><var>H</var></sup></p></td>

<td valign="top" class="noborder"><p>Denotes the conjugate transpose of a general matrix 
            <var class="varname">A</var>. 
            <em>See also</em> conjugate matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><var class="varname">A</var><sup class="power"><var>T</var></sup></p></td>

<td valign="top" class="noborder"><p>Denotes the transpose of a general matrix 
            <var class="varname">A</var>. 
            <em>See also</em> transpose.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>band matrix
        </p></td>

<td valign="top" class="noborder"><p>A general 
            <var class="varname">m</var>-by-<var class="varname">n</var> matrix 
            <var class="varname">A</var> such that 
            <samp class="codeph"><var class="varname">a</var><sub><i class="italic">ij</i></sub> = 0</samp> for 
            <samp class="codeph">|<var class="varname">i</var> - 
              <var class="varname">j</var>| &gt; 
              <var class="varname">l</var></samp>, where 
            <samp class="codeph">1 &lt; 
              <var class="varname">l</var> &lt; min(<var class="varname">m</var>, 
              <var class="varname">n</var>)</samp>. For example, any tridiagonal matrix is a band matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>band storage
        </p></td>

<td valign="top" class="noborder"><p>A special storage scheme for band matrices. A matrix is stored in a two-dimensional array: columns of the matrix are stored in the corresponding columns of the array, and 
            <dfn class="term">diagonals</dfn> of the matrix are stored in rows of the array.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>BLAS
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Basic Linear Algebra Subprograms. These subprograms implement vector, matrix-vector, and matrix-matrix operations.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>BRNG
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Basic Random Number Generator. Basic random number generators are pseudorandom number generators imitating i.i.d. random number sequences of uniform distribution. Distributions other than uniform are generated by applying different transformation techniques to the sequences of random numbers of uniform distribution.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>BRNG registration
        </p></td>

<td valign="top" class="noborder"><p>Standardized mechanism that allows a user to include a user-designed BRNG into the VSL and use it along with the predefined VSL basic generators.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Bunch-Kaufman factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of a real symmetric or complex Hermitian matrix 
            <var class="varname">A</var> in the form 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">PUDU</var><sup><i class="italic">H</i></sup><var class="varname">P</var><sup><i class="italic">T</i></sup></samp> (or 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">PLDL</var><sup><i class="italic">H</i></sup><var class="varname">P</var><sup><i class="italic">T</i></sup></samp>) where 
            <var class="varname">P</var> is a permutation matrix, 
            <var class="varname">U</var> and 
            <var class="varname">L</var> are upper and lower triangular matrices with unit diagonal, and 
            <var class="varname">D</var> is a Hermitian block-diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks. 
            <var class="varname">U</var> and 
            <var class="varname">L</var> have 2-by-2 unit diagonal blocks corresponding to the 2-by-2 blocks of 
            <var class="varname">D</var>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="keyword">c</span></p></td>

<td valign="top" class="noborder"><p>When found as the first letter of routine names, 
            <span class="keyword">c</span> indicates the usage of single-precision complex data type.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>CBLAS
        </p></td>

<td valign="top" class="noborder"><p>C interface to the BLAS. 
            <em>See</em> BLAS.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>CDF
        </p></td>

<td valign="top" class="noborder"><p>Cumulative Distribution Function. The function that determines probability distribution for univariate or multivariate random variable 
            <var class="varname">X</var>. For univariate distribution the cumulative distribution function is the function of real argument 
            <var class="varname">x</var>, which for every 
            <var class="varname">x</var> takes a value equal to probability of the event 
            <samp class="codeph"><var class="varname">A</var>: 
              <var class="varname">X</var><span class="eqsymbol">≤</span><var class="varname">x</var></samp>. For multivariate distribution the cumulative distribution function is the function of a real vector 
            <samp class="codeph"><var class="varname">x</var> = (<var class="varname">x</var><sub><i class="italic">1</i></sub>,<var class="varname">x</var><sub><i class="italic">2</i></sub>, ..., 
              <var class="varname">x</var><sub><i class="italic">n</i></sub>)</samp>, which, for every 
            <var class="varname">x</var>, takes a value equal to probability of the event 
            <samp class="codeph"><var class="varname">A</var> = (<var class="varname">X</var><sub>1</sub><span class="eqsymbol">≤</span><var class="varname">x</var><sub>1</sub> &amp; 
              <var class="varname">X</var><sub>2</sub><span class="eqsymbol">≤</span><var class="varname">x</var><sub>2</sub>, &amp; ..., &amp; 
              <var class="varname">X</var><sub><i class="italic">n</i></sub><span class="eqsymbol">≤</span><var class="varname">x</var><sub><i class="italic">n</i></sub>)</samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Cholesky factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of a symmetric positive-definite or, for complex data, Hermitian positive-definite matrix 
            <var class="varname">A</var> in the form 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">U</var><sup><i class="italic">H</i></sup><var class="varname">U</var></samp> or 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">LL</var><sup><i class="italic">H</i></sup></samp>, where 
            <var class="varname">L</var> is a lower triangular matrix and 
            <var class="varname">U</var> is an upper triangular matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>condition number
        </p></td>

<td valign="top" class="noborder"><p>The number 
            <samp class="codeph"><span class="eqsymbol">κ</span>(<var class="varname">A</var>)</samp> defined for a given square matrix 
            <var class="varname">A</var> as follows: 
            <samp class="codeph"><span class="eqsymbol">κ</span>(<var class="varname">A</var>) = ||<var class="varname">A</var>|| ||<var class="varname">A</var><sup><span class="eqsymbol">−</span>1</sup>||</samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>conjugate matrix
        </p></td>

<td valign="top" class="noborder"><p>The matrix 
            <var class="varname">A</var><sup><i class="italic">H</i></sup> defined for a given general matrix 
            <var class="varname">A</var> as follows: (<samp class="codeph"><var class="varname">A</var><sup><i class="italic">H</i></sup>)<var class="varname"/><sub><i class="italic">ij</i></sub> = (<var class="varname">a</var><sub><i class="italic">ji</i></sub>)<sup>*</sup></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>conjugate number
        </p></td>

<td valign="top" class="noborder"><p>The conjugate of a complex number 
            <samp class="codeph"><var class="varname">z</var> = 
              <var class="varname">a</var> + 
              <var class="varname">bi</var></samp> is 
            <samp class="codeph"><var class="varname">z</var><sup>*</sup> = 
              <var class="varname">a</var> - 
              <var class="varname">bi</var></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="keyword">d</span></p></td>

<td valign="top" class="noborder"><p>When found as the first letter of routine names, 
            <span class="keyword">d</span> indicates the usage of double-precision real data type.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>dot product
        </p></td>

<td valign="top" class="noborder"><p>The number denoted 
            <samp class="codeph"><var class="varname">x</var> · 
              <var class="varname">y</var></samp> and defined for given vectors 
            <var class="varname">x</var> and 
            <var class="varname">y</var> as follows: 
            <samp class="codeph"><var class="varname">x</var> · 
              <var class="varname">y</var> = 
              <span class="eqsymbol">Σ</span><var class="varname"/><sub><i class="italic">i</i></sub><var class="varname">x</var><sub><i class="italic">i</i></sub><var class="varname">y</var><sub><i class="italic">i</i></sub></samp>.
          </p>
<p>Here 
            <var class="varname">x</var><sub><i class="italic">i</i></sub> and 
            <var class="varname">y</var><sub><i class="italic">i</i></sub> stand for the 
            <var>i</var>-th elements of 
            <var class="varname">x</var> and 
            <var class="varname">y</var>, respectively.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>double precision
        </p></td>

<td valign="top" class="noborder"><p>A floating-point data type. On Intel&reg; processors, this data type allows you to store real numbers 
            <var class="varname">x</var> such that 
            <samp class="codeph">2.23*10<sup><span class="eqsymbol">−</span>308</sup>&lt; | 
              <var class="varname">x</var> | &lt; 1.79*10<sup>308</sup></samp>. For this data type, the machine precision 
            <span class="eqsymbol">ε</span> is approximately 10<sup><span class="eqsymbol">−</span>15</sup>, which means that double-precision numbers usually contain no more than 15 significant decimal digits. For more information, refer to 
            <em>Intel&reg; 64 and IA-32 Architectures Software Developer's Manual, Volume 1: Basic Architecture</em>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>eigenvalue
        </p></td>

<td valign="top" class="noborder"><p><em>See</em> eigenvalue problem.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>eigenvalue problem
        </p></td>

<td valign="top" class="noborder"><p>A problem of finding non-zero vectors 
            <var class="varname">x</var> and numbers 
            <span class="eqsymbol">λ</span> (for a given square matrix 
            <var class="varname">A</var>) such that 
            <samp class="codeph"><var class="varname">Ax</var> = 
              <span class="eqsymbol">λ</span><var class="varname">x</var></samp>. Here the numbers 
            <span class="eqsymbol">λ</span> are called the eigenvalues of the matrix 
            <var class="varname">A</var> and the vectors 
            <var class="varname">x</var> are called the eigenvectors of the matrix 
            <var class="varname">A</var>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>eigenvector
        </p></td>

<td valign="top" class="noborder"><p><em>See</em> eigenvalue problem.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>elementary reflector(Householder matrix)
        </p></td>

<td valign="top" class="noborder"><p>Matrix of a general form 
            <samp class="codeph"><var class="varname">H</var> = 
              <var class="varname">I</var><span class="eqsymbol">−</span><span class="eqsymbol">τ</span><var class="varname">vv</var><sup><i class="italic">T</i></sup></samp>, where 
            <var class="varname">v</var> is a column vector and 
            <span class="eqsymbol">τ</span> is a scalar. In LAPACK elementary reflectors are used, for example, to represent the matrix 
            <var class="varname">Q</var> in the 
            <var class="varname">QR</var> factorization (the matrix 
            <var class="varname">Q</var> is represented as a product of elementary reflectors).
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of a matrix as a product of matrices. 
            <em>See also</em> Bunch-Kaufman factorization, Cholesky factorization, 
            <var class="varname">LU</var> factorization, 
            <var class="varname">LQ</var> factorization, 
            <var class="varname">QR</var> factorization, Schur factorization.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>FFTs
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Fast Fourier Transforms. 
            <em>See</em><span>"Fourier Transform Functions"</span>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>full storage
        </p></td>

<td valign="top" class="noborder"><p>A storage scheme allowing you to store matrices of any kind. A matrix 
            <var class="varname">A</var> is stored in a two-dimensional array 
            <var class="varname">a</var>, with the matrix element 
            <samp class="codeph"><var class="varname">a</var><sub><i class="italic">ij</i></sub></samp> stored in the array element 
            <samp class="codeph"><var class="varname">a</var>(<var class="varname">i</var>,<var class="varname">j</var>)</samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Hermitian matrix
        </p></td>

<td valign="top" class="noborder"><p>A square matrix 
            <var class="varname">A</var> that is equal to its conjugate matrix 
            <var class="varname">A</var><sup><i class="italic">H</i></sup>. The conjugate 
            <var class="varname">A</var><sup><i class="italic">H</i></sup> is defined as follows: 
            <samp class="codeph">(<var class="varname">A</var><sup><i class="italic">H</i></sup>)<var class="varname"/><sub><i class="italic">ij</i></sub> = (<var class="varname">a</var><sub><i class="italic">ji</i></sub>)<sup>*</sup></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p/></td>

<td valign="top" class="noborder"><p><em>See</em> identity matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>identity matrix
        </p></td>

<td valign="top" class="noborder"><p>A square matrix 
             whose diagonal elements are 1, and off-diagonal elements are 0. For any matrix 
            <var class="varname">A</var>, 
            <samp class="codeph"><var class="varname">AI</var> = 
              <var class="varname">A</var></samp> and 
            <samp class="codeph"><var class="varname">IA</var> = 
              <var class="varname">A</var></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>i.i.d.
        </p></td>

<td valign="top" class="noborder"><p>Independent Identically Distributed.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>in-place
        </p></td>

<td valign="top" class="noborder"><p>Qualifier of an operation. A function that performs its operation in-place takes its input from an array and returns its output to the same array.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Intel&reg; oneAPI Math Kernel Library</p></td>

<td valign="top" class="noborder"><p>Abbreviation for Intel&reg; oneAPI Math Kernel Library.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>inverse matrix
        </p></td>

<td valign="top" class="noborder"><p>The matrix denoted as A<sup><span class="eqsymbol">−</span>1</sup> and defined for a given square matrix 
            <var class="varname">A</var> as follows: 
            <samp class="codeph"><var class="varname">AA</var><sup><span class="eqsymbol">−</span>1</sup> = 
              <var class="varname">A</var><sup><span class="eqsymbol">−</span>1</sup><var class="varname">A</var> = 
              <var class="varname">I</var></samp>. 
            <samp class="codeph"><var class="varname">A</var><sup><span class="eqsymbol">−</span>1</sup></samp> does not exist for singular matrices 
            <var class="varname">A</var>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><var class="varname">LQ</var> factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of an 
            <var class="varname">m</var>-by-<var class="varname">n</var> matrix 
            <var class="varname">A</var> as 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">LQ</var></samp> or 
            <samp class="codeph"><var class="varname">A</var> = (<var class="varname">L</var> 0)<var class="varname">Q</var></samp>. Here 
            <var class="varname">Q</var> is an 
            <var class="varname">n</var>-by-<var class="varname">n</var> orthogonal (unitary) matrix. For 
            <samp class="codeph"><var class="varname">m</var><span class="eqsymbol">≤</span><var class="varname">n</var></samp>, 
            <var class="varname">L</var> is an 
            <var class="varname">m</var>-by-<var class="varname">m</var> lower triangular matrix with real diagonal elements; for 
            <samp class="codeph"><var class="varname">m</var> &gt; 
              <var class="varname">n</var></samp>, 
          </p>
<p><br/><div class="imagecenter"><img src="GUID-53B7CDC4-30EB-476A-81D2-12336A7E416E-low.gif" align="center"/></div><br/></p>
<p>where 
            <var class="varname">L</var><sub><i class="italic">1</i></sub> is an 
            <var class="varname">n</var>-by-<var class="varname">n</var> lower triangular matrix, and 
            <var class="varname">L</var><sub><i class="italic">2</i></sub> is a rectangular matrix. 
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><var>LU</var> factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of a general 
            <var class="varname">m</var>-by-<var class="varname">n</var> matrix 
            <var class="varname">A</var> as 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">PLU</var></samp>, where 
            <var class="varname">P</var> is a permutation matrix, 
            <var class="varname">L</var> is lower triangular with unit diagonal elements (lower trapezoidal if 
            <samp class="codeph"><var class="varname">m</var> &gt; 
              <var class="varname">n</var></samp>) and 
            <var class="varname">U</var> is upper triangular (upper trapezoidal if 
            <samp class="codeph"><var class="varname">m</var> &lt; 
              <var class="varname">n</var></samp>).
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>machine precision
        </p></td>

<td valign="top" class="noborder"><p>The number 
            <span class="eqsymbol">ε</span> determining the precision of the machine representation of real numbers. For Intel&reg; architecture, the machine precision is approximately 10<sup><span class="eqsymbol">−</span>7</sup> for single-precision data, and approximately 10<sup><span class="eqsymbol">−</span>15</sup> for double-precision data. The precision also determines the number of significant decimal digits in the machine representation of real numbers. 
            <em>See also</em> double precision and single precision.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>MPI
        </p></td>

<td valign="top" class="noborder"><p>Message Passing Interface. This standard defines the user interface and functionality for a wide range of message-passing capabilities in parallel computing. 
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>MPICH
        </p></td>

<td valign="top" class="noborder"><p>A freely available, portable implementation of MPI standard for message-passing libraries.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>orthogonal matrix
        </p></td>

<td valign="top" class="noborder"><p>A real square matrix 
            <var class="varname">A</var> whose transpose and inverse are equal, that is, 
            <samp class="codeph"><var class="varname">A</var><sup><i class="italic">T</i></sup> = 
              <var class="varname">A</var><sup><i class="italic">-1</i></sup></samp>, and therefore 
            <samp class="codeph"><var class="varname">AA</var><sup><i class="italic">T</i></sup> = 
              <var class="varname">A</var><sup>T</sup><var class="varname">A</var> = 
              <var class="varname">I</var></samp>. All eigenvalues of an orthogonal matrix have the absolute value 1.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>packed storage
        </p></td>

<td valign="top" class="noborder"><p>A storage scheme allowing you to store symmetric, Hermitian, or triangular matrices more compactly. The upper or lower triangle of a matrix is packed by columns in a one-dimensional array.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>PDF
        </p></td>

<td valign="top" class="noborder"><p>Probability Density Function. The function that determines probability distribution for univariate or multivariate continuous random variable 
            <var class="varname">X</var>. The probability density function 
            <var class="varname">f</var>(<var class="varname">x</var>) is closely related with the cumulative distribution function 
            <var class="varname">F</var>(<var class="varname">x</var>).
          </p>
<p>For univariate distribution the relation is
          </p>
<p><br/><div class="imagecenter"><img src="GUID-E32B6DD1-6B9B-4392-BB4D-F4D474DAD9BC-low.jpg" align="center"/></div><br/></p>
<p>For multivariate distribution the relation is
          </p>
<br/><img src="GUID-51ADEF19-3747-4B92-A533-A7A820FED7D3-low.jpg" alt="Equation" align="absmiddle" class=".eq"/><br/></td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>positive-definite matrix
        </p></td>

<td valign="top" class="noborder"><p>A square matrix 
            <var class="varname">A</var> such that 
            <samp class="codeph"><var class="varname">Ax</var> · 
              <var class="varname">x</var> &gt; 0</samp> for any non-zero vector 
            <var class="varname">x</var>. Here · denotes the dot product.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>pseudorandom number generator
        </p></td>

<td valign="top" class="noborder"><p>A completely deterministic algorithm that imitates truly random sequences.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><var>QR</var> factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of an 
            <var class="varname">m</var>-by-<var class="varname">n</var> matrix 
            <var class="varname">A</var> as 
            <samp class="codeph"><var class="varname">A = QR</var></samp>, where 
            <var class="varname">Q</var> is an 
            <var class="varname">m</var>-by-<var class="varname">m</var> orthogonal (unitary) matrix, and 
            <var class="varname">R</var> is 
            <var class="varname">n</var>-by-<var class="varname">n</var> upper triangular with real diagonal elements (if 
            <samp class="codeph"><var class="varname">m</var><span class="eqsymbol">≥</span><var class="varname">n</var></samp>) or trapezoidal (if 
            <samp class="codeph"><var class="varname">m</var> &lt; 
              <var class="varname">n</var></samp>) matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>random stream
        </p></td>

<td valign="top" class="noborder"><p>An abstract source of independent identically distributed random numbers of uniform distribution. In this manual a random stream points to a structure that uniquely defines a random number sequence generated by a basic generator associated with a given random stream.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>RNG
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Random Number Generator. In this manual the term "random number generators" stands for pseudorandom number generators, that is, generators based on completely deterministic algorithms imitating truly random sequences.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Rectangular Full Packed (RFP) storage
        </p></td>

<td valign="top" class="noborder"><p>A storage scheme combining the full and packed storage schemes for the upper or lower triangle of the matrix. This combination enables using half of the full storage as packed storage while maintaining efficiency by using Level 3 BLAS/LAPACK kernels as the full storage.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="keyword">s</span></p></td>

<td valign="top" class="noborder"><p>When found as the first letter of routine names, 
            <span class="keyword">s</span> indicates the usage of single-precision real data type.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>ScaLAPACK
        </p></td>

<td valign="top" class="noborder"><p>Stands for Scalable Linear Algebra PACKage.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>Schur factorization
        </p></td>

<td valign="top" class="noborder"><p>Representation of a square matrix 
            <var class="varname">A</var> in the form 
            <samp class="codeph"><var class="varname">A</var> = 
              <var class="varname">ZTZ</var><sup><i class="italic">H</i></sup></samp>. Here T is an upper quasi-triangular matrix (for complex 
            <var class="varname">A</var>, triangular matrix) called the Schur form of 
            <var class="varname">A</var>; the matrix 
            <var class="varname">Z</var> is orthogonal (for complex 
            <var class="varname">A</var>, unitary). Columns of 
            <var class="varname">Z</var> are called Schur vectors.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>single precision
        </p></td>

<td valign="top" class="noborder"><p>A floating-point data type. On Intel&reg; processors, this data type allows you to store real numbers 
            <var class="varname">x</var> such that 
            <samp class="codeph">1.18*10<sup><span class="eqsymbol">−</span>38</sup> &lt; | 
              <var class="varname">x</var> | &lt; 3.40*10<sup>38</sup></samp>. For this data type, the machine precision (<span class="eqsymbol">ε</span>) is approximately 10<sup><span class="eqsymbol">−</span>7</sup>, which means that single-precision numbers usually contain no more than 7 significant decimal digits. For more information, refer to 
            <em>Intel&reg; 64 and IA-32 Architectures Software Developer's Manual, Volume 1: Basic Architecture</em>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>singular matrix
        </p></td>

<td valign="top" class="noborder"><p>A matrix whose determinant is zero. If 
            <var class="varname">A</var> is a singular matrix, the inverse 
            <samp class="codeph"><var class="varname">A</var><sup>-1</sup></samp> does not exist, and the system of equations 
            <samp class="codeph"><var class="varname">Ax</var> = 
              <var class="varname">b</var></samp> does not have a unique solution (that is, there exist no solutions or an infinite number of solutions).
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>singular value
        </p></td>

<td valign="top" class="noborder"><p>The numbers defined for a given general matrix 
            <var class="varname">A</var> as the eigenvalues of the matrix 
            <var class="varname">AA</var><sup><i class="italic">H</i></sup>. 
            <em>See also</em> SVD.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>SMP
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Symmetric MultiProcessing. Intel&reg; oneAPI Math Kernel Library offers performance gains through parallelism provided by the SMP feature.</p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>sparse BLAS
        </p></td>

<td valign="top" class="noborder"><p>Routines performing basic vector operations on sparse vectors. Sparse BLAS routines take advantage of vectors' sparsity: they allow you to store only non-zero elements of vectors. 
            <em>See</em> BLAS.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>sparse vectors
        </p></td>

<td valign="top" class="noborder"><p>Vectors in which most of the components are zeros.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>storage scheme
        </p></td>

<td valign="top" class="noborder"><p>The way of storing matrices. 
            <em>See</em> full storage, packed storage, and band storage.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>SVD
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Singular Value Decomposition. 
            <em>See also</em> Singular value decomposition section in 
            <span>"LAPACK Auxiliary and Utility Routines"</span>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>symmetric matrix
        </p></td>

<td valign="top" class="noborder"><p>A square matrix 
            <var class="varname">A</var> such that 
            <samp class="codeph"><var class="varname">a</var><sub><i class="italic">ij</i></sub> = 
              <var class="varname">a</var><sub><i class="italic">ji</i></sub></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>transpose
        </p></td>

<td valign="top" class="noborder"><p>The transpose of a given matrix 
            <var class="varname">A</var> is a matrix 
            <samp class="codeph"><var class="varname">A</var><sup><i class="italic">T</i></sup></samp> such that (<samp class="codeph"><var class="varname">A</var><sup><i class="italic">T</i></sup>)<sub><i class="italic">ij</i></sub> = 
              <var class="varname">a</var><sub><i class="italic">ji</i></sub></samp> (rows of 
            <var class="varname">A</var> become columns of 
            <var class="varname">A</var><sup><i class="italic">T</i></sup>, and columns of 
            <var class="varname">A</var> become rows of 
            <var class="varname">A</var><sup><i class="italic">T</i></sup>).
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>trapezoidal matrix
        </p></td>

<td valign="top" class="noborder"><p>A matrix 
            <var class="varname">A</var> such that 
            <samp class="codeph"><var class="varname">A</var> = (<var class="varname">A</var><sub><i class="italic">1</i></sub><var class="varname">A</var><sub><i class="italic">2</i></sub>)</samp>, where 
            <var class="varname">A</var><sub><i class="italic">1</i></sub> is an upper triangular matrix, 
            <var class="varname">A</var><sub><i class="italic">2</i></sub> is a rectangular matrix.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>triangular matrix
        </p></td>

<td valign="top" class="noborder"><p>A matrix 
            <var class="varname">A</var> is called an upper (lower) triangular matrix if all its subdiagonal elements (superdiagonal elements) are zeros. Thus, for an upper triangular matrix 
            <samp class="codeph"><var class="varname">a</var><sub><i class="italic">ij</i></sub> = 0</samp> when 
            <samp class="codeph"><var class="varname">i</var> &gt; 
              <var class="varname">j</var></samp>; for a lower triangular matrix 
            <samp class="codeph"><var class="varname">a</var><sub><i class="italic">ij</i></sub> = 0</samp> when 
            <samp class="codeph"><var class="varname">i</var> &lt; 
              <var class="varname">j</var></samp>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>tridiagonal matrix
        </p></td>

<td valign="top" class="noborder"><p>A matrix whose non-zero elements are in three diagonals only: the leading diagonal, the first subdiagonal, and the first super-diagonal.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>unitary matrix
        </p></td>

<td valign="top" class="noborder"><p>A complex square matrix 
            <var class="varname">A</var> whose conjugate and inverse are equal, that is, that is, 
            <samp class="codeph"><var class="varname">A</var><sup><i class="italic">H</i></sup> = 
              <var class="varname">A</var><sup><i class="italic">-1</i></sup></samp>, and therefore 
            <samp class="codeph"><var class="varname">AA</var><sup><i class="italic">H</i></sup> = 
              <var class="varname">A</var><sup><i class="italic">H</i></sup><var class="varname">A = I</var></samp>. All eigenvalues of a unitary matrix have the absolute value 1.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>VML
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Vector Mathematical Library. 
            <em>See</em><span>"Vector Mathematical Functions"</span>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p>VSL
        </p></td>

<td valign="top" class="noborder"><p>Abbreviation for Vector Statistical Library. 
            <em>See</em><span>"Statistical Functions"</span>.
          </p>
</td>
</tr><tr><td valign="top" width="30%" class="noborder"><p><span class="keyword">z</span></p></td>

<td valign="top" class="noborder"><p>When found as the first letter of routine names, 
            <span class="keyword">z</span> indicates the usage of double-precision complex data type.
          </p>
</td>
</tr></table></div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-0191F247-778C-4C69-B54F-ABF951506FCD.html">Developer Reference for Intel&reg; oneAPI Math Kernel Library - Fortran</a></div>
</div>
<div/>
</body>
</html>
