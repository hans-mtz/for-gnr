<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0016)http://localhost -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="DC.Type" content="FunctionRef"/>
<meta name="DC.Title" content="p?syevx"/>
<meta name="abstract" content="Computes selected eigenvalues and, optionally, eigenvectors of a symmetric matrix."/>
<meta name="description" content="Computes selected eigenvalues and, optionally, eigenvectors of a symmetric matrix."/>
<meta name="DC.subject" content="p?syevx, ScaLAPACK routines, driver routines, symmetric matrix, eigenvalues and eigenvectors"/>
<meta name="keywords" content="p?syevx, ScaLAPACK routines, driver routines, symmetric matrix, eigenvalues and eigenvectors"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792"/>
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-0E684CCB-0D14-4DBB-8EDE-BE9A8B499D94"/>
<meta name="DC.Language" content="en-US"/>
<link rel="stylesheet" type="text/css" href="intel_css_styles.css"/>
<title>p?syevx</title>

</head>
<body id="GUID-0E684CCB-0D14-4DBB-8EDE-BE9A8B499D94">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; oneAPI Math Kernel Library Developer Reference - Fortran</em></p>


<h1 class="topictitle1"><span class="option">p?syevx</span></h1>
<!--Computes selected eigenvalues and, optionally, eigenvectors of a symmetric matrix.--><div><p class="shortdesc">Computes selected eigenvalues and, optionally, eigenvectors of a symmetric matrix.</p>
<div class="section" id="GUID-E261488F-3529-41D0-B7DC-01ABA17B950E"><h2 class="sectiontitle">Syntax</h2><dl class="dlsyntax"><p class="dlsyntaxpara"><span class="kwd">call pssyevx</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p><p class="dlsyntaxpara"><span class="kwd">call pdsyevx</span><span class="delim">(</span><span class="var">jobz</span><span class="sep">, </span><span class="var">range</span><span class="sep">, </span><span class="var">uplo</span><span class="sep">, </span><span class="var">n</span><span class="sep">, </span><span class="var">a</span><span class="sep">, </span><span class="var">ia</span><span class="sep">, </span><span class="var">ja</span><span class="sep">, </span><span class="var">desca</span><span class="sep">, </span><span class="var">vl</span><span class="sep">, </span><span class="var">vu</span><span class="sep">, </span><span class="var">il</span><span class="sep">, </span><span class="var">iu</span><span class="sep">, </span><span class="var">abstol</span><span class="sep">, </span><span class="var">m</span><span class="sep">, </span><span class="var">nz</span><span class="sep">, </span><span class="var">w</span><span class="sep">, </span><span class="var">orfac</span><span class="sep">, </span><span class="var">z</span><span class="sep">, </span><span class="var">iz</span><span class="sep">, </span><span class="var">jz</span><span class="sep">, </span><span class="var">descz</span><span class="sep">, </span><span class="var">work</span><span class="sep">, </span><span class="var">lwork</span><span class="sep">, </span><span class="var">iwork</span><span class="sep">, </span><span class="var">liwork</span><span class="sep">, </span><span class="var">ifail</span><span class="sep">, </span><span class="var">iclustr</span><span class="sep">, </span><span class="var">gap</span><span class="sep">, </span><span class="var">info</span><span class="delim">)</span></p></dl></div>
<div class="section" id="GUID-C4174865-2540-4A85-93B4-2EC9B7EF13E7"><h2 class="sectiontitle">Include Files</h2><p/>
</div>
<div class="section" id="GUID-EF0BA884-508E-4F3F-8512-A9CC95F9C018"><h2 class="sectiontitle">Description</h2><p><span/>The <span class="option">p?syevx</span><span>routine </span>computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix <var>A</var> by calling the recommended sequence of ScaLAPACK <span>routines</span>. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<p>
<div class="tablenoborder"><table cellpadding="4" summary="" id="d433e46" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" align="left" valign="top" width="100%" id="d113487e318"><p id="d433e52">Optimization Notice 
              </p>
</th>
</tr>
</thead>
<tbody><tr><td class="bgcolor(#f5f5f5)" bgcolor="#f5f5f5" valign="top" width="100%" headers="d113487e318 "><p>Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
              </p>
<p> Notice revision #20110804 
              </p>
</td>
</tr>
</tbody>
</table>
</div>
 This notice covers the following instruction sets: SSE2, SSE4.2, AVX2, AVX-512. 
    </p>
</div>
<div class="section" id="GUID-330B42F3-C7C2-4B76-8A40-0CABBBE49D76"><h2 class="sectiontitle">Input Parameters</h2><p><var>np</var> = the number of rows local to a given process. </p>
<p><var>nq</var> = the number of columns local to a given process. </p>
<dl id="GUID-0E626B42-57AB-4567-8CC9-9F9F1C8C9755"><dt class="dlterm"><span class="parmname">jobz</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'N'</span> or <span class="keyword">'V'</span>. Specifies if it is necessary to compute the eigenvectors: </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword">'N'</span></samp>, then only eigenvalues are computed. </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword">'V'</span></samp>, then eigenvalues and eigenvectors are computed.</p>
</dd>
<dt class="dlterm"><span class="parmname">range</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'A'</span>, <span class="keyword">'V'</span>, or <span class="keyword">'I'</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp>, all eigenvalues will be found. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, all eigenvalues in the half-open interval <samp class="codeph">[<var>vl</var>, <var>vu</var>]</samp> will be found. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'I'</span></samp>, the eigenvalues with indices <var>il</var> through <var>iu</var> will be found. </p>
</dd>
<dt class="dlterm"><span class="parmname">uplo</span></dt>

<dd><p>(global) <span><span class="keyword">CHARACTER*1</span>. </span>Must be <span class="keyword">'U'</span> or <span class="keyword">'L'</span>.</p>
<p>Specifies whether the upper or lower triangular part of the symmetric matrix <var>A</var> is stored: </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, <var>a</var> stores the upper triangular part of <var>A</var>. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, <var>a</var> stores the lower triangular part of <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">n</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The number of rows and columns of the matrix <var>A</var><samp class="codeph">(<var>n</var><span class="eqsymbol">≥</span> 0)</samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>(local). <span><span class="keyword">REAL</span> for <span class="option">pssyevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>. </p>
<p>Block cyclic array of global size <span>(<var>n</var>, <var>n</var>)</span> and local size <samp class="codeph">(<var>lld_a</var>, <var>LOC</var><var>c</var>(<var>ja</var>+<var>n</var>-1))</samp>. On entry, the symmetric matrix <var>A</var>. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>, only the upper triangular part of <var>A</var> is used to define the elements of the symmetric matrix. </p>
<p>If <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>, only the lower triangular part of <var>A</var> is used to define the elements of the symmetric matrix. </p>
</dd>
<dt class="dlterm"><span class="parmname">ia</span>, <span class="parmname">ja</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>A</var> indicating the first row and the first column of the submatrix <var>A</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">desca</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <var>A</var>.</p>
</dd>
<dt class="dlterm"><span class="parmname">vl</span>, <span class="parmname">vu</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssyevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>. </p>
<p>If <samp class="codeph"><var>range</var> = <span class="keyword">'V'</span></samp>, the lower and upper bounds of the interval to be searched for eigenvalues; <samp class="codeph"><var>vl</var> ≤ <var>vu</var></samp>. Not referenced if <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'I'</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">il</span>, <span class="parmname">iu</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>range</var> =<span class="keyword">'I'</span></samp>, the indices of the smallest and largest eigenvalues to be returned. </p>
<p>Constraints: <samp class="codeph"><var>il</var> ≥ 1 </samp></p>
<p><samp class="codeph">min(<var>il</var>,<var>n</var>) ≤ <var>iu</var> ≤ <var>n</var></samp></p>
<p>Not referenced if <samp class="codeph"><var>range</var> = <span class="keyword">'A'</span></samp> or <span class="keyword">'V'</span>.</p>
</dd>
<dt class="dlterm"><span class="parmname">abstol</span></dt>

<dd><p>(global).<span><span class="keyword">REAL</span> for <span class="option">pssyevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>. </p>
<p>If <samp class="codeph"><var>jobz</var>=<span class="keyword">'V'</span></samp>, setting <var>abstol</var> to <samp class="codeph"><span class="option">p?lamch</span>(<var>context</var>, <span class="keyword">'U'</span>)</samp> yields the most orthogonal eigenvectors. </p>
<p>The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval <samp class="codeph">[<var>a</var>, <var>b</var>]</samp> of width less than or equal to </p>
<p><samp class="codeph"><var>abstol</var> + <var>eps</var> * max(|<var>a</var>|,|<var>b</var>|)</samp>, </p>
<p>where <var>eps</var> is the machine precision. If <var>abstol</var> is less than or equal to zero, then <var>eps</var>*norm(<span class="keyword">T</span>) will be used in its place, where norm(<span class="keyword">T</span>) is the 1-norm of the tridiagonal matrix obtained by reducing <var>A</var> to tridiagonal form. </p>
<p>Eigenvalues will be computed most accurately when <var>abstol</var> is set to twice the underflow threshold <samp class="codeph">2*<span class="option">p?lamch</span>('S')</samp> not zero. If this<span> routine </span>returns with <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2) <span class="eqsymbol">≠</span> 0)</samp> or  <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/8,2) <span class="eqsymbol">≠</span> 0))</samp>, indicating that some eigenvalues or eigenvectors did not converge, try setting <samp class="codeph"><var>abstol</var></samp> to <samp class="codeph">2*<span class="option">p?lamch</span>(<span class="keyword">'S'</span>)</samp>. </p>
</dd>
<dt class="dlterm"><span class="parmname">orfac</span></dt>

<dd><p>(global).<span><span class="keyword">REAL</span> for <span class="option">pssyevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>. </p>
<p>Specifies which eigenvectors should be reorthogonalized. Eigenvectors that correspond to eigenvalues which are within <samp class="codeph"><var>tol</var>=<var>orfac</var>*norm(<var>A</var>)</samp>of each other are to be reorthogonalized. However, if the workspace is insufficient (see <var>lwork</var>), <var>tol</var> may be decreased until all eigenvectors to be reorthogonalized can be stored in one process. No reorthogonalization will be done if <var>orfac</var> equals zero. A default value of 1.0e-3 is used if <var>orfac</var> is negative. <var>orfac</var> should be identical on all processes. </p>
</dd>
<dt class="dlterm"><span class="parmname">iz</span>, <span class="parmname">jz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The row and column indices in the global matrix <var>Z</var> indicating the first row and the first column of the submatrix <var>Z</var>, respectively.</p>
</dd>
<dt class="dlterm"><span class="parmname">descz</span></dt>

<dd><p>(global and local) <span><span class="keyword">INTEGER</span></span> array of size <var>dlen_</var>.  The array descriptor for the distributed matrix <samp class="codeph"><var>Z</var>.</samp><span class="parmname">descz</span><samp class="codeph">(<var>ctxt_</var>)</samp> must equal <span class="parmname">desca</span><samp class="codeph">(<var>ctxt_</var>)</samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">work</span></dt>

<dd><p>(local)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssyevx</span>. </p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>. </p>
<p>Array of size <var>lwork</var>. </p>
</dd>
<dt class="dlterm"><span class="parmname">lwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>The size of the array <var>work</var>. </p>
<p>See below for definitions of variables used to define <var>lwork</var>. </p>
<p>If no eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>), then <samp class="codeph"><var>lwork</var> ≥ 5*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <span class="keyword">NB</span>*(<var>np</var>0 + 1))</samp>. </p>
<p>If eigenvectors are requested (<samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>), then the amount of workspace required to guarantee that all eigenvectors are computed is: </p>
<p><samp class="codeph"><var>lwork</var> ≥ 5*<var>n</var> + <span class="keyword">max</span>(5*<var>nn</var>, <var>np</var>0*<var>mq</var>0 + 2*<span class="keyword">NB</span>*<span class="keyword">NB</span>) + <span class="keyword">iceil</span>(<var>neig</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)*<var>nn</var></samp></p>
<p>The computed eigenvectors may not be orthogonal if the minimal workspace is supplied and <var>orfac</var> is too small. If you want to guarantee orthogonality (at the cost of potentially poor performance) you should add the following to <var>lwork</var>:</p>
<p><samp class="codeph"> (<var>clustersize</var>-1)*<var>n</var></samp>,</p>
<p>where <var>clustersize</var> is the number of eigenvalues in the largest cluster, where a cluster is defined as a set of close eigenvalues: </p>
<p><samp class="codeph">{<var>w</var>(<var>k</var>),..., <var>w</var>(<var>k</var>+<var>clustersize</var>-1)|</samp><samp class="codeph"><var>w</var>(<var>j</var>+1) ≤  <var>w</var>(<var>j</var>)) + <var>orfac</var>*2*norm(<var>A</var>)}</samp>,</p>
<p> where </p>
<p><samp class="codeph"><var>neig</var> = </samp>number of eigenvectors requested </p>
<p><samp class="codeph"><var>nb</var> = <var>desca</var>(<var>mb_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>mb_</var>) = <var>descz</var>(<var>nb_</var>); </samp></p>
<p><samp class="codeph"><var>nn</var> = <span class="keyword">max</span>(<var>n</var>, <var>nb</var>, 2); </samp></p>
<p><samp class="codeph"><var>desca</var>(<var>rsrc_</var>) = <var>desca</var>(<var>nb_</var>) = <var>descz</var>(<var>rsrc_</var>) = <var>descz</var>(<var>csrc_</var>) = 0; </samp></p>
<p><samp class="codeph"><var>np</var>0 = <span class="keyword">numroc</span>(<var>nn</var>, <var>nb</var>, 0, 0, <span class="keyword">NPROW</span>);</samp></p>
<p><samp class="codeph"><var>mq</var>0 = <span class="keyword">numroc</span>(<span class="keyword">ma</span>x(<var>neig</var>, <var>nb</var>, 2), <var>nb</var>, 0, 0, <span class="keyword">NPCOL</span>) <span class="keyword"/></samp></p>
<p><samp class="codeph"><span class="keyword">iceil</span>(<var>x</var>, <var>y</var>)</samp> is a ScaLAPACK function returning ceiling(<var>x</var>/<var>y</var>) </p>
<p> If <var>lwork</var> is too small to guarantee orthogonality, <span class="option">p?syevx</span> attempts to maintain orthogonality in the clusters with the smallest spacing between the eigenvalues. </p>
<p>If <var>lwork</var> is too small to compute all the eigenvectors requested, no computation is performed and <var>info</var>= -23 is returned. </p>
<p>Note that when <samp class="codeph"><var>range</var>=<span class="keyword">'V'</span>,</samp> number of requested eigenvectors are not known until the eigenvalues are computed. In this case and if  <var>lwork</var> is large enough to compute the eigenvalues, <span class="option">p?sygvx</span> computes the eigenvalues and as many eigenvectors as possible.</p>
<p><u>Relationship between workspace, orthogonality &amp; performance: </u></p>
<p>Greater performance can be achieved if adequate workspace is provided. In some situations, performance can decrease as the provided workspace increases above the workspace amount shown below: </p>
<p><samp class="codeph"><var>lwork</var> ≥ <span class="keyword">max</span>(<var>lwork</var>, 5*<var>n</var> + <var>nsytrd_lwopt</var>)</samp>,</p>
<p>where <var>lwork</var>, as defined previously, depends upon the number of eigenvectors requested, and </p>
<p><samp class="codeph"><var>nsytrd_lwopt</var> = <var>n</var> + 2*(<var>anb</var>+1)*(4*<var>nps</var>+2) + (<var>nps</var> + 3)*<var>nps;</var></samp></p>
<p><samp class="codeph"><var>anb</var> = <span class="option">pjlaenv</span>(<var>desca</var><span>(<var>ctxt_</var>)</span>, 3, '<span class="option">p?syttrd</span>', <span class="keyword">'L'</span>, 0, 0, 0, 0); </samp></p>
<p><samp class="codeph"><var>sqnpc</var> = <span class="keyword">int</span>(<var>sqrt</var>(<var>dble</var>(<span class="keyword">NPROW</span> * <span class="keyword">NPCOL</span>)));</samp></p>
<p><samp class="codeph"><var>nps</var> = <span class="keyword">max</span>(<span class="keyword">numroc</span>(<var>n</var>, 1, 0, 0, <var>sqnpc</var>), 2*<var>anb</var>);</samp></p>
<p><span class="keyword">numroc</span> is a ScaLAPACK tool functions; <span class="option"/></p>
<p><span class="option">pjlaenv</span> is a ScaLAPACK environmental inquiry function </p>
<p><span class="keyword">MYROW</span>, <span class="keyword">MYCOL</span>, <span class="keyword">NPROW</span> and <span class="keyword">NPCOL</span> can be determined by calling the <span>subroutine </span><span class="keyword">blacs_gridinfo</span>. </p>
<p>For large <span class="keyword">n</span>, no extra workspace is needed, however the biggest boost in performance comes for small <span class="keyword">n</span>, so it is wise to provide the extra workspace (typically less than a megabyte per process).</p>
<p>If <samp class="codeph"><var>clustersize</var> &gt; <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp>, then providing enough space to compute all the eigenvectors orthogonally will cause serious degradation in performance. At the limit (that is, <samp class="codeph"><var>clustersize</var> = <var>n</var>-1</samp>)  <span class="option">p?stein</span> will perform no better than <span class="keyword">?stein</span> on single processor. </p>
<p>For <samp class="codeph"><var>clustersize</var> = <var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> reorthogonalizing all eigenvectors will increase the total execution time by a factor of 2 or more. </p>
<p>For <samp class="codeph"><var>clustersize</var><span class="eqsymbol">&gt;</span><var>n</var>/<var>sqrt</var>(<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp> execution time will grow as the square of the cluster size, all other factors remaining equal and assuming enough workspace. Less workspace means less reorthogonalization but faster execution. </p>
<p>If <samp class="codeph"><samp class="codeph"><var>lwork</var> = -1</samp></samp>, then <var>lwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the size required for optimal performance for all work arrays. Each of these values is returned in the first entry of the corresponding work arrays, and no error message is issued by <span class="option">pxerbla</span>. </p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span></dt>

<dd><p>(local) <span><span class="keyword">INTEGER</span>. </span>Workspace array.</p>
</dd>
<dt class="dlterm"><span class="parmname">liwork</span></dt>

<dd><p>(local) <span class="keyword">INTEGER</span>, size of <var>iwork</var>. <samp class="codeph"><var>liwork</var> ≥ 6*<var>nnp</var></samp></p>
<p>Where: <samp class="codeph"><var>nnp</var> = <span class="keyword">max</span>(<var>n</var>, <span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span> + 1, 4)</samp></p>
<p>If <samp class="codeph"><var>liwork</var> = -1</samp>, then <var>liwork</var> is global input and a workspace query is assumed; the<span> routine </span>only calculates the minimum and optimal size for all work arrays. Each of these values is returned in the first entry of the corresponding work array, and no error message is issued by <span class="option">pxerbla</span>.</p>
</dd>
</dl>
</div>
<div class="section" id="GUID-23CFF1BA-CCC5-45D9-AB06-9312BAB97904"><h2 class="sectiontitle">Output Parameters</h2><dl id="GUID-B2FEC090-789E-4D91-B1DA-DB7715AAE14B"><dt class="dlterm"><span class="parmname">a</span></dt>

<dd><p>On exit, the lower triangle (if <samp class="codeph"><var>uplo</var> = <span class="keyword">'L'</span></samp>) or the upper triangle (if <samp class="codeph"><var>uplo</var> = <span class="keyword">'U'</span></samp>)of <var>A</var>, including the diagonal, is overwritten. </p>
</dd>
<dt class="dlterm"><span class="parmname">m</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>The total number of eigenvalues found; <samp class="codeph">0 ≤ <var>m</var> ≤ <var>  n</var></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">nz</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>Total number of eigenvectors computed. <samp class="codeph">0 ≤ <var> nz</var> ≤ <var> m</var></samp>. </p>
<p>The number of columns of <var>z</var> that are filled. </p>
<p>If <samp class="codeph"><var>jobz</var> ≠ <span class="keyword">'V'</span></samp>, <var>nz</var> is not referenced. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'V'</span></samp>, <samp class="codeph"><var>nz</var> = <var>m</var></samp> unless the user supplies insufficient space and <span class="option">p?syevx</span> is not able to detect this before beginning computation. To get all the eigenvectors requested, the user must supply both sufficient space to hold the eigenvectors in <samp class="codeph"><var>z</var> (<var>m</var><span class="eqsymbol">≤</span><var>descz</var><span>(<var>n_</var>)</span>)</samp> and sufficient workspace to compute them. (See <var>lwork</var>). <span class="option">p?syevx</span> is always able to detect insufficient space without computation unless <var>range</var> = <span class="keyword">'V'</span>. </p>
</dd>
<dt class="dlterm"><span class="parmname">w</span></dt>

<dd><p>(global).<span><span class="keyword">REAL</span> for <span class="option">pssyevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>.</p>
<p>Array of size <var>n</var>. The first <var>m</var> elements contain the selected eigenvalues in ascending order.</p>
</dd>
<dt class="dlterm"><span class="parmname">z</span></dt>

<dd><p>(local).<span><span class="keyword">REAL</span> for <span class="option">pssyevx</span></span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>.</p>
<p>Array, global size <span>(<var>n</var>, <var>n</var>)</span>, local size <samp class="codeph">(<var>lld_z</var>, <var>LOCc</var>(<var>jz</var>+<var>n</var>-1))</samp>.</p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword"> 'V'</span></samp>, then on normal exit the first <var>m</var> columns of <var>z</var> contain the orthonormal eigenvectors of the matrix corresponding to the selected eigenvalues. If an eigenvector fails to converge, then that column of <var>z</var> contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in <var>ifail</var>. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then <var>z</var> is not referenced. </p>
</dd>
<dt class="dlterm"><span class="parmname">work</span><samp class="codeph">(1)</samp></dt>

<dd><p>On exit, returns workspace adequate workspace to allow optimal performance. </p>
</dd>
<dt class="dlterm"><span class="parmname">iwork</span><samp class="codeph">(1)</samp></dt>

<dd><p>On return, <span class="parmname">iwork</span><samp class="codeph">(1)</samp> contains the amount of integer workspace required.</p>
</dd>
<dt class="dlterm"><span class="parmname">ifail</span></dt>

<dd><p>(global)<span><span class="keyword">INTEGER</span></span>.</p>
<p>Array of size <var>n</var>. </p>
<p>If <samp class="codeph"><var>jobz</var> =<span class="keyword"> 'V'</span></samp>, then on normal exit, the first <var>m</var> elements of <var>ifail</var> are zero. If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2) <span class="eqsymbol">≠</span> 0)</samp> on exit, then <var>ifail</var> contains the indices of the eigenvectors that failed to converge. </p>
<p>If <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>, then <var>ifail</var> is not referenced. </p>
</dd>
<dt class="dlterm"><span class="parmname">iclustr</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span>Array of size <samp class="codeph">(2*<span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span>)</samp></p>
<p>This array contains indices of eigenvectors corresponding to a cluster of eigenvalues that could not be reorthogonalized due to insufficient workspace (see <var>lwork</var>, <var>orfac</var> and <var>info</var>). Eigenvectors corresponding to clusters of eigenvalues indexed <samp class="codeph"><var>iclustr</var>(2*<var>i</var>-1) to <var>iclustr</var>(2*<var>i</var>)</samp>, could not be reorthogonalized due to lack of workspace. Hence the eigenvectors corresponding to these clusters may not be orthogonal. <var>iclustr</var><span>()</span> is a zero terminated array. <samp class="codeph"><var>iclustr</var><span>(2*<var>k</var>) </span><span class="eqsymbol">≠</span> 0</samp>  and <samp class="codeph"><var>iclustr</var><span>(2*<var>k</var>+1)</span> = 0</samp> if and only if <var>k</var> is the number of clusters. </p>
<p><var>iclustr</var> is not referenced if <samp class="codeph"><var>jobz</var> = <span class="keyword">'N'</span></samp>.</p>
</dd>
<dt class="dlterm"><span class="parmname">gap</span></dt>

<dd><p>(global)</p>
<p><span class="keyword">REAL</span> for <span class="option">pssyevx</span></p>
<p><span class="keyword">DOUBLE PRECISION</span> for <span class="option">pdsyevx</span>.</p>
<p>Array of size <samp class="codeph"><span class="keyword">NPROW</span>*<span class="keyword">NPCOL</span></samp></p>
<p>This array contains the gap between eigenvalues whose eigenvectors could not be reorthogonalized. The output values in this array correspond to the clusters indicated by the array <var>iclustr</var>. As a result, the dot product between eigenvectors corresponding to the <var>i</var>th cluster may be as high as <samp class="codeph">(<var>C</var>*<var>n</var>)/<var>gap</var><span>(<var>i</var>)</span></samp> where <var>C</var> is a small constant. </p>
</dd>
<dt class="dlterm"><span class="parmname">info</span></dt>

<dd><p>(global) <span><span class="keyword">INTEGER</span>. </span></p>
<p>If <samp class="codeph"><var>info</var> = 0</samp>, the execution is successful. </p>
<p>If <samp class="codeph"><var>info</var> &lt; 0</samp>: </p>
<p>If the <var>i</var>-th argument is an array and the <var>j</var>-entry had an illegal value, then <samp class="codeph"><var>info</var> = -(<var>i</var>*100+<var>j</var>)</samp>, if the <var>i</var>-th argument is a scalar and had an illegal value, then <samp class="codeph"><var>info</var> = -<var>i</var></samp>. </p>
<p>If <samp class="codeph"><var>info</var><span class="eqsymbol">&gt;</span> 0</samp>: if <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>,2)<span class="eqsymbol">≠</span>0)</samp>, then one or more eigenvectors failed to converge. Their indices are stored in <var>ifail</var>. Ensure <samp class="codeph"><var>abstol</var>=2.0*<span class="option">p?lamch</span>(<span class="keyword">'U'</span>)</samp>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/2,2)<span class="eqsymbol">≠</span>0)</samp>, then eigenvectors corresponding to one or more clusters of eigenvalues could not be reorthogonalized because of insufficient workspace.The indices of the clusters are stored in the array <var>iclustr</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/4,2)<span class="eqsymbol">≠</span>0)</samp>, then space limit prevented<span class="option"> p?syevx</span>f rom computing all of the eigenvectors between <var>vl</var> and <var>vu</var>. The number of eigenvectors computed is returned in <var>nz</var>. </p>
<p>If <samp class="codeph">(<span class="keyword">mod</span>(<var>info</var>/8,2)<span class="eqsymbol">≠</span>0)</samp>, then<span class="option"> p?stebz</span> failed to compute eigenvalues. Ensure <samp class="codeph"><var>abstol</var>=2.0*<span class="option">p?lamch</span>(<span class="keyword">'U'</span>)</samp>.</p>
<div class="Note"><h3 class="NoteTipHead">Note</h3> <p><samp class="codeph">mod(<var>x</var>,<var>y</var>)</samp> is the integer remainder of <samp class="codeph"><var>x</var>/<var>y</var></samp>.</p>
</div>
</dd>
</dl>
</div>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-CF5CF672-F6FD-41A7-A0BC-CAAEFBD035EE.html">ScaLAPACK Driver Routines</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-97273960-E4A4-4016-8667-BE6A36156792.html#GUID-97273960-E4A4-4016-8667-BE6A36156792">Overview</a> for details of ScaLAPACK  array descriptor structures and related notations.</div></div></div>
</body>
</html>
